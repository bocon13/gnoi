// Code generated by protoc-gen-go.
// source: system/system.proto
// DO NOT EDIT!

/*
Package gnoi_system is a generated protocol buffer package.

It is generated from these files:
	system/system.proto

It has these top-level messages:
	SwitchControlProcessorRequest
	SwitchControlProcessorResponse
	RebootRequest
	RebootResponse
	CancelRebootRequest
	CancelRebootResponse
	RebootStatusRequest
	RebootStatusResponse
	TimeRequest
	TimeResponse
	PingRequest
	PingResponse
	TracerouteRequest
	TracerouteResponse
	RemoteDownload
	Package
	SetPackageRequest
	SetPackageResponse
*/
package gnoi_system

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import gnoi "github.com/openconfig/gnoi"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// A RebootMethod determines what should be done with a target when a Reboot is
// requested.  Only the COLD method is required to be supported by all
// targets.  Methods the target does not support should result in failure.
//
// It is vendor defined if a WARM reboot is the same as an NSF reboot.
type RebootMethod int32

const (
	RebootMethod_UNKNOWN   RebootMethod = 0
	RebootMethod_COLD      RebootMethod = 1
	RebootMethod_POWERDOWN RebootMethod = 2
	RebootMethod_HALT      RebootMethod = 3
	RebootMethod_WARM      RebootMethod = 4
	RebootMethod_NSF       RebootMethod = 5
	RebootMethod_RESET     RebootMethod = 6
	RebootMethod_POWERUP   RebootMethod = 7
)

var RebootMethod_name = map[int32]string{
	0: "UNKNOWN",
	1: "COLD",
	2: "POWERDOWN",
	3: "HALT",
	4: "WARM",
	5: "NSF",
	6: "RESET",
	7: "POWERUP",
}
var RebootMethod_value = map[string]int32{
	"UNKNOWN":   0,
	"COLD":      1,
	"POWERDOWN": 2,
	"HALT":      3,
	"WARM":      4,
	"NSF":       5,
	"RESET":     6,
	"POWERUP":   7,
}

func (x RebootMethod) String() string {
	return proto.EnumName(RebootMethod_name, int32(x))
}
func (RebootMethod) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type TracerouteRequest_L4Protocol int32

const (
	TracerouteRequest_ICMP TracerouteRequest_L4Protocol = 0
	TracerouteRequest_TCP  TracerouteRequest_L4Protocol = 1
	TracerouteRequest_UDP  TracerouteRequest_L4Protocol = 2
)

var TracerouteRequest_L4Protocol_name = map[int32]string{
	0: "ICMP",
	1: "TCP",
	2: "UDP",
}
var TracerouteRequest_L4Protocol_value = map[string]int32{
	"ICMP": 0,
	"TCP":  1,
	"UDP":  2,
}

func (x TracerouteRequest_L4Protocol) String() string {
	return proto.EnumName(TracerouteRequest_L4Protocol_name, int32(x))
}
func (TracerouteRequest_L4Protocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{12, 0}
}

// State is the resulting state of a single traceoroute packet.
type TracerouteResponse_State int32

const (
	TracerouteResponse_DEFAULT              TracerouteResponse_State = 0
	TracerouteResponse_NONE                 TracerouteResponse_State = 1
	TracerouteResponse_UNKNOWN              TracerouteResponse_State = 2
	TracerouteResponse_ICMP                 TracerouteResponse_State = 3
	TracerouteResponse_HOST_UNREACHABLE     TracerouteResponse_State = 4
	TracerouteResponse_NETWORK_UNREACHABLE  TracerouteResponse_State = 5
	TracerouteResponse_PROTOCOL_UNREACHABLE TracerouteResponse_State = 6
	TracerouteResponse_SOURCE_ROUTE_FAILED  TracerouteResponse_State = 7
	TracerouteResponse_FRAGMENTATION_NEEDED TracerouteResponse_State = 8
	TracerouteResponse_PROHIBITED           TracerouteResponse_State = 9
	TracerouteResponse_PRECEDENCE_VIOLATION TracerouteResponse_State = 10
	TracerouteResponse_PRECEDENCE_CUTOFF    TracerouteResponse_State = 11
)

var TracerouteResponse_State_name = map[int32]string{
	0:  "DEFAULT",
	1:  "NONE",
	2:  "UNKNOWN",
	3:  "ICMP",
	4:  "HOST_UNREACHABLE",
	5:  "NETWORK_UNREACHABLE",
	6:  "PROTOCOL_UNREACHABLE",
	7:  "SOURCE_ROUTE_FAILED",
	8:  "FRAGMENTATION_NEEDED",
	9:  "PROHIBITED",
	10: "PRECEDENCE_VIOLATION",
	11: "PRECEDENCE_CUTOFF",
}
var TracerouteResponse_State_value = map[string]int32{
	"DEFAULT":              0,
	"NONE":                 1,
	"UNKNOWN":              2,
	"ICMP":                 3,
	"HOST_UNREACHABLE":     4,
	"NETWORK_UNREACHABLE":  5,
	"PROTOCOL_UNREACHABLE": 6,
	"SOURCE_ROUTE_FAILED":  7,
	"FRAGMENTATION_NEEDED": 8,
	"PROHIBITED":           9,
	"PRECEDENCE_VIOLATION": 10,
	"PRECEDENCE_CUTOFF":    11,
}

func (x TracerouteResponse_State) String() string {
	return proto.EnumName(TracerouteResponse_State_name, int32(x))
}
func (TracerouteResponse_State) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{13, 0} }

type RemoteDownload_DownloadType int32

const (
	RemoteDownload_UNKNOWN RemoteDownload_DownloadType = 0
	RemoteDownload_SFTP    RemoteDownload_DownloadType = 1
	RemoteDownload_HTTP    RemoteDownload_DownloadType = 2
	RemoteDownload_HTTPS   RemoteDownload_DownloadType = 3
	RemoteDownload_SCP     RemoteDownload_DownloadType = 4
)

var RemoteDownload_DownloadType_name = map[int32]string{
	0: "UNKNOWN",
	1: "SFTP",
	2: "HTTP",
	3: "HTTPS",
	4: "SCP",
}
var RemoteDownload_DownloadType_value = map[string]int32{
	"UNKNOWN": 0,
	"SFTP":    1,
	"HTTP":    2,
	"HTTPS":   3,
	"SCP":     4,
}

func (x RemoteDownload_DownloadType) String() string {
	return proto.EnumName(RemoteDownload_DownloadType_name, int32(x))
}
func (RemoteDownload_DownloadType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{14, 0}
}

type SwitchControlProcessorRequest struct {
	ControlProcessor *gnoi.Path `protobuf:"bytes,1,opt,name=control_processor,json=controlProcessor" json:"control_processor,omitempty"`
}

func (m *SwitchControlProcessorRequest) Reset()                    { *m = SwitchControlProcessorRequest{} }
func (m *SwitchControlProcessorRequest) String() string            { return proto.CompactTextString(m) }
func (*SwitchControlProcessorRequest) ProtoMessage()               {}
func (*SwitchControlProcessorRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *SwitchControlProcessorRequest) GetControlProcessor() *gnoi.Path {
	if m != nil {
		return m.ControlProcessor
	}
	return nil
}

type SwitchControlProcessorResponse struct {
	ControlProcessor *gnoi.Path `protobuf:"bytes,1,opt,name=control_processor,json=controlProcessor" json:"control_processor,omitempty"`
	Version          string     `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
	Uptime           int64      `protobuf:"varint,3,opt,name=uptime" json:"uptime,omitempty"`
}

func (m *SwitchControlProcessorResponse) Reset()                    { *m = SwitchControlProcessorResponse{} }
func (m *SwitchControlProcessorResponse) String() string            { return proto.CompactTextString(m) }
func (*SwitchControlProcessorResponse) ProtoMessage()               {}
func (*SwitchControlProcessorResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *SwitchControlProcessorResponse) GetControlProcessor() *gnoi.Path {
	if m != nil {
		return m.ControlProcessor
	}
	return nil
}

func (m *SwitchControlProcessorResponse) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *SwitchControlProcessorResponse) GetUptime() int64 {
	if m != nil {
		return m.Uptime
	}
	return 0
}

// A RebootRequest requests the specified target be rebooted using the specified
// method aftar the specified delay.  Only the DEFAULT method with a delay of 0
// is guaranteed to be accepted for all target types.
type RebootRequest struct {
	Method RebootMethod `protobuf:"varint,1,opt,name=method,enum=gnoi.system.RebootMethod" json:"method,omitempty"`
	// Delay in nanoseconds before issuing reboot.
	Delay uint64 `protobuf:"varint,2,opt,name=delay" json:"delay,omitempty"`
	// Informational reason for the reboot.
	Message string `protobuf:"bytes,3,opt,name=message" json:"message,omitempty"`
	// Optional sub-components to reboot.
	Subcomponents []*gnoi.Path `protobuf:"bytes,4,rep,name=subcomponents" json:"subcomponents,omitempty"`
	// Force reboot if sanity checks fail. (ex. uncommited configuration)
	Force bool `protobuf:"varint,5,opt,name=force" json:"force,omitempty"`
}

func (m *RebootRequest) Reset()                    { *m = RebootRequest{} }
func (m *RebootRequest) String() string            { return proto.CompactTextString(m) }
func (*RebootRequest) ProtoMessage()               {}
func (*RebootRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *RebootRequest) GetMethod() RebootMethod {
	if m != nil {
		return m.Method
	}
	return RebootMethod_UNKNOWN
}

func (m *RebootRequest) GetDelay() uint64 {
	if m != nil {
		return m.Delay
	}
	return 0
}

func (m *RebootRequest) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *RebootRequest) GetSubcomponents() []*gnoi.Path {
	if m != nil {
		return m.Subcomponents
	}
	return nil
}

func (m *RebootRequest) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

type RebootResponse struct {
}

func (m *RebootResponse) Reset()                    { *m = RebootResponse{} }
func (m *RebootResponse) String() string            { return proto.CompactTextString(m) }
func (*RebootResponse) ProtoMessage()               {}
func (*RebootResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// A CancelRebootRequest requests the cancelation of any outstanding reboot
// request.
type CancelRebootRequest struct {
	Message       string       `protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`
	Subcomponents []*gnoi.Path `protobuf:"bytes,2,rep,name=subcomponents" json:"subcomponents,omitempty"`
}

func (m *CancelRebootRequest) Reset()                    { *m = CancelRebootRequest{} }
func (m *CancelRebootRequest) String() string            { return proto.CompactTextString(m) }
func (*CancelRebootRequest) ProtoMessage()               {}
func (*CancelRebootRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *CancelRebootRequest) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *CancelRebootRequest) GetSubcomponents() []*gnoi.Path {
	if m != nil {
		return m.Subcomponents
	}
	return nil
}

type CancelRebootResponse struct {
}

func (m *CancelRebootResponse) Reset()                    { *m = CancelRebootResponse{} }
func (m *CancelRebootResponse) String() string            { return proto.CompactTextString(m) }
func (*CancelRebootResponse) ProtoMessage()               {}
func (*CancelRebootResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type RebootStatusRequest struct {
	Subcomponents []*gnoi.Path `protobuf:"bytes,1,rep,name=subcomponents" json:"subcomponents,omitempty"`
}

func (m *RebootStatusRequest) Reset()                    { *m = RebootStatusRequest{} }
func (m *RebootStatusRequest) String() string            { return proto.CompactTextString(m) }
func (*RebootStatusRequest) ProtoMessage()               {}
func (*RebootStatusRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *RebootStatusRequest) GetSubcomponents() []*gnoi.Path {
	if m != nil {
		return m.Subcomponents
	}
	return nil
}

type RebootStatusResponse struct {
	Active bool   `protobuf:"varint,1,opt,name=active" json:"active,omitempty"`
	Wait   uint64 `protobuf:"varint,2,opt,name=wait" json:"wait,omitempty"`
	When   uint64 `protobuf:"varint,3,opt,name=when" json:"when,omitempty"`
	Reason string `protobuf:"bytes,4,opt,name=reason" json:"reason,omitempty"`
	Count  uint32 `protobuf:"varint,5,opt,name=count" json:"count,omitempty"`
}

func (m *RebootStatusResponse) Reset()                    { *m = RebootStatusResponse{} }
func (m *RebootStatusResponse) String() string            { return proto.CompactTextString(m) }
func (*RebootStatusResponse) ProtoMessage()               {}
func (*RebootStatusResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *RebootStatusResponse) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *RebootStatusResponse) GetWait() uint64 {
	if m != nil {
		return m.Wait
	}
	return 0
}

func (m *RebootStatusResponse) GetWhen() uint64 {
	if m != nil {
		return m.When
	}
	return 0
}

func (m *RebootStatusResponse) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *RebootStatusResponse) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

// A TimeRequest requests the current time accodring to the target.
type TimeRequest struct {
}

func (m *TimeRequest) Reset()                    { *m = TimeRequest{} }
func (m *TimeRequest) String() string            { return proto.CompactTextString(m) }
func (*TimeRequest) ProtoMessage()               {}
func (*TimeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type TimeResponse struct {
	Time uint64 `protobuf:"varint,1,opt,name=time" json:"time,omitempty"`
}

func (m *TimeResponse) Reset()                    { *m = TimeResponse{} }
func (m *TimeResponse) String() string            { return proto.CompactTextString(m) }
func (*TimeResponse) ProtoMessage()               {}
func (*TimeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *TimeResponse) GetTime() uint64 {
	if m != nil {
		return m.Time
	}
	return 0
}

// A PingRequest describes the ping operation to perform.  Only the destination
// fields is required.  Any field not specified is set to a reasonable server
// specified value.  Not all fields are supported by all vendors.
//
// A count of 0 defaults to a vendor specified value, typically 5.  A count of
// -1 means continue until the RPC times out or is canceled.
//
// If the interval is -1 then a flood ping is issued.
//
// If the size is 0, the vendor default size will be used (typically 56 bytes).
type PingRequest struct {
	Destination   string          `protobuf:"bytes,1,opt,name=destination" json:"destination,omitempty"`
	Source        string          `protobuf:"bytes,2,opt,name=source" json:"source,omitempty"`
	Count         int32           `protobuf:"varint,3,opt,name=count" json:"count,omitempty"`
	Interval      int64           `protobuf:"varint,4,opt,name=interval" json:"interval,omitempty"`
	Wait          int64           `protobuf:"varint,5,opt,name=wait" json:"wait,omitempty"`
	Size          int32           `protobuf:"varint,6,opt,name=size" json:"size,omitempty"`
	DoNotFragment bool            `protobuf:"varint,7,opt,name=do_not_fragment,json=doNotFragment" json:"do_not_fragment,omitempty"`
	DoNotResolve  bool            `protobuf:"varint,8,opt,name=do_not_resolve,json=doNotResolve" json:"do_not_resolve,omitempty"`
	L3Protocol    gnoi.L3Protocol `protobuf:"varint,9,opt,name=l3protocol,enum=gnoi.L3Protocol" json:"l3protocol,omitempty"`
}

func (m *PingRequest) Reset()                    { *m = PingRequest{} }
func (m *PingRequest) String() string            { return proto.CompactTextString(m) }
func (*PingRequest) ProtoMessage()               {}
func (*PingRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *PingRequest) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *PingRequest) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *PingRequest) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *PingRequest) GetInterval() int64 {
	if m != nil {
		return m.Interval
	}
	return 0
}

func (m *PingRequest) GetWait() int64 {
	if m != nil {
		return m.Wait
	}
	return 0
}

func (m *PingRequest) GetSize() int32 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *PingRequest) GetDoNotFragment() bool {
	if m != nil {
		return m.DoNotFragment
	}
	return false
}

func (m *PingRequest) GetDoNotResolve() bool {
	if m != nil {
		return m.DoNotResolve
	}
	return false
}

func (m *PingRequest) GetL3Protocol() gnoi.L3Protocol {
	if m != nil {
		return m.L3Protocol
	}
	return gnoi.L3Protocol_UNSPECIFIED
}

// A PingResponse represents either the reponse to a single ping packet
// (the bytes field is non-zero) or the summary statistics (sent is non-zero).
//
// For a single ping packet, time is the round trip time, in nanoseconds.  For
// summary statistics, it is the time spent by the ping operation.  The time is
// not always present in summary statistics.  The std_dev is not always present
// in summary statistics.
type PingResponse struct {
	Source   string `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	Time     int64  `protobuf:"varint,2,opt,name=time" json:"time,omitempty"`
	Sent     int32  `protobuf:"varint,3,opt,name=sent" json:"sent,omitempty"`
	Received int32  `protobuf:"varint,4,opt,name=received" json:"received,omitempty"`
	MinTime  int64  `protobuf:"varint,5,opt,name=min_time,json=minTime" json:"min_time,omitempty"`
	AvgTime  int64  `protobuf:"varint,6,opt,name=avg_time,json=avgTime" json:"avg_time,omitempty"`
	MaxTime  int64  `protobuf:"varint,7,opt,name=max_time,json=maxTime" json:"max_time,omitempty"`
	StdDev   int64  `protobuf:"varint,8,opt,name=std_dev,json=stdDev" json:"std_dev,omitempty"`
	Bytes    int32  `protobuf:"varint,11,opt,name=bytes" json:"bytes,omitempty"`
	Sequence int32  `protobuf:"varint,12,opt,name=sequence" json:"sequence,omitempty"`
	Ttl      int32  `protobuf:"varint,13,opt,name=ttl" json:"ttl,omitempty"`
}

func (m *PingResponse) Reset()                    { *m = PingResponse{} }
func (m *PingResponse) String() string            { return proto.CompactTextString(m) }
func (*PingResponse) ProtoMessage()               {}
func (*PingResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *PingResponse) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *PingResponse) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *PingResponse) GetSent() int32 {
	if m != nil {
		return m.Sent
	}
	return 0
}

func (m *PingResponse) GetReceived() int32 {
	if m != nil {
		return m.Received
	}
	return 0
}

func (m *PingResponse) GetMinTime() int64 {
	if m != nil {
		return m.MinTime
	}
	return 0
}

func (m *PingResponse) GetAvgTime() int64 {
	if m != nil {
		return m.AvgTime
	}
	return 0
}

func (m *PingResponse) GetMaxTime() int64 {
	if m != nil {
		return m.MaxTime
	}
	return 0
}

func (m *PingResponse) GetStdDev() int64 {
	if m != nil {
		return m.StdDev
	}
	return 0
}

func (m *PingResponse) GetBytes() int32 {
	if m != nil {
		return m.Bytes
	}
	return 0
}

func (m *PingResponse) GetSequence() int32 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *PingResponse) GetTtl() int32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

// A TracerouteRequest describes the traceroute operation to perform.  Only the
// destination field is required.  Any field not specified is set to a
// reasonable server specified value.  Not all fields are supported by all
// vendors.
//
// If the hop_count is -1 the traceroute will continue forever.
//
type TracerouteRequest struct {
	Source        string                       `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	Destination   string                       `protobuf:"bytes,2,opt,name=destination" json:"destination,omitempty"`
	InitialTtl    uint32                       `protobuf:"varint,3,opt,name=initial_ttl,json=initialTtl" json:"initial_ttl,omitempty"`
	MaxTtl        int32                        `protobuf:"varint,4,opt,name=max_ttl,json=maxTtl" json:"max_ttl,omitempty"`
	Wait          int64                        `protobuf:"varint,5,opt,name=wait" json:"wait,omitempty"`
	DoNotFragment bool                         `protobuf:"varint,6,opt,name=do_not_fragment,json=doNotFragment" json:"do_not_fragment,omitempty"`
	DoNotResolve  bool                         `protobuf:"varint,7,opt,name=do_not_resolve,json=doNotResolve" json:"do_not_resolve,omitempty"`
	L3Protocol    gnoi.L3Protocol              `protobuf:"varint,8,opt,name=l3protocol,enum=gnoi.L3Protocol" json:"l3protocol,omitempty"`
	L4Protocol    TracerouteRequest_L4Protocol `protobuf:"varint,9,opt,name=l4protocol,enum=gnoi.system.TracerouteRequest_L4Protocol" json:"l4protocol,omitempty"`
}

func (m *TracerouteRequest) Reset()                    { *m = TracerouteRequest{} }
func (m *TracerouteRequest) String() string            { return proto.CompactTextString(m) }
func (*TracerouteRequest) ProtoMessage()               {}
func (*TracerouteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *TracerouteRequest) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *TracerouteRequest) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *TracerouteRequest) GetInitialTtl() uint32 {
	if m != nil {
		return m.InitialTtl
	}
	return 0
}

func (m *TracerouteRequest) GetMaxTtl() int32 {
	if m != nil {
		return m.MaxTtl
	}
	return 0
}

func (m *TracerouteRequest) GetWait() int64 {
	if m != nil {
		return m.Wait
	}
	return 0
}

func (m *TracerouteRequest) GetDoNotFragment() bool {
	if m != nil {
		return m.DoNotFragment
	}
	return false
}

func (m *TracerouteRequest) GetDoNotResolve() bool {
	if m != nil {
		return m.DoNotResolve
	}
	return false
}

func (m *TracerouteRequest) GetL3Protocol() gnoi.L3Protocol {
	if m != nil {
		return m.L3Protocol
	}
	return gnoi.L3Protocol_UNSPECIFIED
}

func (m *TracerouteRequest) GetL4Protocol() TracerouteRequest_L4Protocol {
	if m != nil {
		return m.L4Protocol
	}
	return TracerouteRequest_ICMP
}

// A TraceRouteResponse contains the result of a single traceoute packet.
//
// There may be an optional initial response that provides information about the
// traceroute request itself and contains at least one of the fields in the the
// initial block of fields and none of the fields following that block.  All
// subsequent responses should not contain any of these fields.
//
// Typically multiple responses are received for each hop, as the packets are
// received.
//
// The mpls field maps names to values.  Example names include "Label", "CoS",
// "TTL", "S", and "MRU".
// [Perhaps we should list the canonical names that must be used when
// applicable].
type TracerouteResponse struct {
	// The following fields are only filled in for the first message.
	// If any of these fields are specified, all fields following this
	// block are left unspecified.
	DestinationName    string `protobuf:"bytes,1,opt,name=destination_name,json=destinationName" json:"destination_name,omitempty"`
	DestinationAddress string `protobuf:"bytes,2,opt,name=destination_address,json=destinationAddress" json:"destination_address,omitempty"`
	Hops               int32  `protobuf:"varint,3,opt,name=hops" json:"hops,omitempty"`
	PacketSize         int32  `protobuf:"varint,4,opt,name=packet_size,json=packetSize" json:"packet_size,omitempty"`
	// The following fields provide the disposition of a single traceroute
	// packet.
	Hop      int32                    `protobuf:"varint,5,opt,name=hop" json:"hop,omitempty"`
	Address  string                   `protobuf:"bytes,6,opt,name=address" json:"address,omitempty"`
	Name     string                   `protobuf:"bytes,7,opt,name=name" json:"name,omitempty"`
	Rtt      int64                    `protobuf:"varint,8,opt,name=rtt" json:"rtt,omitempty"`
	State    TracerouteResponse_State `protobuf:"varint,9,opt,name=state,enum=gnoi.system.TracerouteResponse_State" json:"state,omitempty"`
	IcmpCode int32                    `protobuf:"varint,10,opt,name=icmp_code,json=icmpCode" json:"icmp_code,omitempty"`
	Mpls     map[string]string        `protobuf:"bytes,11,rep,name=mpls" json:"mpls,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	AsPath   []int32                  `protobuf:"varint,12,rep,packed,name=as_path,json=asPath" json:"as_path,omitempty"`
}

func (m *TracerouteResponse) Reset()                    { *m = TracerouteResponse{} }
func (m *TracerouteResponse) String() string            { return proto.CompactTextString(m) }
func (*TracerouteResponse) ProtoMessage()               {}
func (*TracerouteResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *TracerouteResponse) GetDestinationName() string {
	if m != nil {
		return m.DestinationName
	}
	return ""
}

func (m *TracerouteResponse) GetDestinationAddress() string {
	if m != nil {
		return m.DestinationAddress
	}
	return ""
}

func (m *TracerouteResponse) GetHops() int32 {
	if m != nil {
		return m.Hops
	}
	return 0
}

func (m *TracerouteResponse) GetPacketSize() int32 {
	if m != nil {
		return m.PacketSize
	}
	return 0
}

func (m *TracerouteResponse) GetHop() int32 {
	if m != nil {
		return m.Hop
	}
	return 0
}

func (m *TracerouteResponse) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *TracerouteResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TracerouteResponse) GetRtt() int64 {
	if m != nil {
		return m.Rtt
	}
	return 0
}

func (m *TracerouteResponse) GetState() TracerouteResponse_State {
	if m != nil {
		return m.State
	}
	return TracerouteResponse_DEFAULT
}

func (m *TracerouteResponse) GetIcmpCode() int32 {
	if m != nil {
		return m.IcmpCode
	}
	return 0
}

func (m *TracerouteResponse) GetMpls() map[string]string {
	if m != nil {
		return m.Mpls
	}
	return nil
}

func (m *TracerouteResponse) GetAsPath() []int32 {
	if m != nil {
		return m.AsPath
	}
	return nil
}

// RemoteDownload defines the details for a device to initiate a download of a
// package from a remote location.
type RemoteDownload struct {
	// The path information containing where to download the package from.
	// For HTTP(S), this will be the URL (i.e. foo.com/file.tbz2).
	// For SFTP and SCP, this will be the address:/path/to/file
	// (i.e. host.foo.com:/bar/baz).
	Path         string                      `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	DownloadType RemoteDownload_DownloadType `protobuf:"varint,2,opt,name=download_type,json=downloadType,enum=gnoi.system.RemoteDownload_DownloadType" json:"download_type,omitempty"`
	Credentials  *gnoi.Credentials           `protobuf:"bytes,3,opt,name=credentials" json:"credentials,omitempty"`
}

func (m *RemoteDownload) Reset()                    { *m = RemoteDownload{} }
func (m *RemoteDownload) String() string            { return proto.CompactTextString(m) }
func (*RemoteDownload) ProtoMessage()               {}
func (*RemoteDownload) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *RemoteDownload) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *RemoteDownload) GetDownloadType() RemoteDownload_DownloadType {
	if m != nil {
		return m.DownloadType
	}
	return RemoteDownload_UNKNOWN
}

func (m *RemoteDownload) GetCredentials() *gnoi.Credentials {
	if m != nil {
		return m.Credentials
	}
	return nil
}

// Package defines a single package file to be placed on the target.
type Package struct {
	// Destination path and filename of the package.
	Filename string `protobuf:"bytes,1,opt,name=filename" json:"filename,omitempty"`
	// Version of the package. (vendor internal name)
	Version string `protobuf:"bytes,4,opt,name=version" json:"version,omitempty"`
	// For system packages this will take effect after reboot.
	Activate bool `protobuf:"varint,5,opt,name=activate" json:"activate,omitempty"`
	// Details for the device to download the package from a remote location.
	RemoteDownload *RemoteDownload `protobuf:"bytes,6,opt,name=remote_download,json=remoteDownload" json:"remote_download,omitempty"`
}

func (m *Package) Reset()                    { *m = Package{} }
func (m *Package) String() string            { return proto.CompactTextString(m) }
func (*Package) ProtoMessage()               {}
func (*Package) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *Package) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *Package) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Package) GetActivate() bool {
	if m != nil {
		return m.Activate
	}
	return false
}

func (m *Package) GetRemoteDownload() *RemoteDownload {
	if m != nil {
		return m.RemoteDownload
	}
	return nil
}

// SetPackageRequest will place the package onto the target and optionally mark
// it as the next bootable image. The initial message must be a package
// message containing the filename and information about the file. Following the
// initial message the contents are then streamed in maximum 64k chunks. The
// final message must be a hash message contains the hash of the file contents.
type SetPackageRequest struct {
	// Types that are valid to be assigned to Request:
	//	*SetPackageRequest_Package
	//	*SetPackageRequest_Contents
	//	*SetPackageRequest_Hash
	Request isSetPackageRequest_Request `protobuf_oneof:"request"`
}

func (m *SetPackageRequest) Reset()                    { *m = SetPackageRequest{} }
func (m *SetPackageRequest) String() string            { return proto.CompactTextString(m) }
func (*SetPackageRequest) ProtoMessage()               {}
func (*SetPackageRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

type isSetPackageRequest_Request interface {
	isSetPackageRequest_Request()
}

type SetPackageRequest_Package struct {
	Package *Package `protobuf:"bytes,1,opt,name=package,oneof"`
}
type SetPackageRequest_Contents struct {
	Contents []byte `protobuf:"bytes,2,opt,name=contents,proto3,oneof"`
}
type SetPackageRequest_Hash struct {
	Hash *gnoi.HashType `protobuf:"bytes,3,opt,name=hash,oneof"`
}

func (*SetPackageRequest_Package) isSetPackageRequest_Request()  {}
func (*SetPackageRequest_Contents) isSetPackageRequest_Request() {}
func (*SetPackageRequest_Hash) isSetPackageRequest_Request()     {}

func (m *SetPackageRequest) GetRequest() isSetPackageRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *SetPackageRequest) GetPackage() *Package {
	if x, ok := m.GetRequest().(*SetPackageRequest_Package); ok {
		return x.Package
	}
	return nil
}

func (m *SetPackageRequest) GetContents() []byte {
	if x, ok := m.GetRequest().(*SetPackageRequest_Contents); ok {
		return x.Contents
	}
	return nil
}

func (m *SetPackageRequest) GetHash() *gnoi.HashType {
	if x, ok := m.GetRequest().(*SetPackageRequest_Hash); ok {
		return x.Hash
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SetPackageRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SetPackageRequest_OneofMarshaler, _SetPackageRequest_OneofUnmarshaler, _SetPackageRequest_OneofSizer, []interface{}{
		(*SetPackageRequest_Package)(nil),
		(*SetPackageRequest_Contents)(nil),
		(*SetPackageRequest_Hash)(nil),
	}
}

func _SetPackageRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SetPackageRequest)
	// request
	switch x := m.Request.(type) {
	case *SetPackageRequest_Package:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Package); err != nil {
			return err
		}
	case *SetPackageRequest_Contents:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.Contents)
	case *SetPackageRequest_Hash:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Hash); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SetPackageRequest.Request has unexpected type %T", x)
	}
	return nil
}

func _SetPackageRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SetPackageRequest)
	switch tag {
	case 1: // request.package
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Package)
		err := b.DecodeMessage(msg)
		m.Request = &SetPackageRequest_Package{msg}
		return true, err
	case 2: // request.contents
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Request = &SetPackageRequest_Contents{x}
		return true, err
	case 3: // request.hash
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(gnoi.HashType)
		err := b.DecodeMessage(msg)
		m.Request = &SetPackageRequest_Hash{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SetPackageRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SetPackageRequest)
	// request
	switch x := m.Request.(type) {
	case *SetPackageRequest_Package:
		s := proto.Size(x.Package)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SetPackageRequest_Contents:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Contents)))
		n += len(x.Contents)
	case *SetPackageRequest_Hash:
		s := proto.Size(x.Hash)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type SetPackageResponse struct {
}

func (m *SetPackageResponse) Reset()                    { *m = SetPackageResponse{} }
func (m *SetPackageResponse) String() string            { return proto.CompactTextString(m) }
func (*SetPackageResponse) ProtoMessage()               {}
func (*SetPackageResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func init() {
	proto.RegisterType((*SwitchControlProcessorRequest)(nil), "gnoi.system.SwitchControlProcessorRequest")
	proto.RegisterType((*SwitchControlProcessorResponse)(nil), "gnoi.system.SwitchControlProcessorResponse")
	proto.RegisterType((*RebootRequest)(nil), "gnoi.system.RebootRequest")
	proto.RegisterType((*RebootResponse)(nil), "gnoi.system.RebootResponse")
	proto.RegisterType((*CancelRebootRequest)(nil), "gnoi.system.CancelRebootRequest")
	proto.RegisterType((*CancelRebootResponse)(nil), "gnoi.system.CancelRebootResponse")
	proto.RegisterType((*RebootStatusRequest)(nil), "gnoi.system.RebootStatusRequest")
	proto.RegisterType((*RebootStatusResponse)(nil), "gnoi.system.RebootStatusResponse")
	proto.RegisterType((*TimeRequest)(nil), "gnoi.system.TimeRequest")
	proto.RegisterType((*TimeResponse)(nil), "gnoi.system.TimeResponse")
	proto.RegisterType((*PingRequest)(nil), "gnoi.system.PingRequest")
	proto.RegisterType((*PingResponse)(nil), "gnoi.system.PingResponse")
	proto.RegisterType((*TracerouteRequest)(nil), "gnoi.system.TracerouteRequest")
	proto.RegisterType((*TracerouteResponse)(nil), "gnoi.system.TracerouteResponse")
	proto.RegisterType((*RemoteDownload)(nil), "gnoi.system.RemoteDownload")
	proto.RegisterType((*Package)(nil), "gnoi.system.Package")
	proto.RegisterType((*SetPackageRequest)(nil), "gnoi.system.SetPackageRequest")
	proto.RegisterType((*SetPackageResponse)(nil), "gnoi.system.SetPackageResponse")
	proto.RegisterEnum("gnoi.system.RebootMethod", RebootMethod_name, RebootMethod_value)
	proto.RegisterEnum("gnoi.system.TracerouteRequest_L4Protocol", TracerouteRequest_L4Protocol_name, TracerouteRequest_L4Protocol_value)
	proto.RegisterEnum("gnoi.system.TracerouteResponse_State", TracerouteResponse_State_name, TracerouteResponse_State_value)
	proto.RegisterEnum("gnoi.system.RemoteDownload_DownloadType", RemoteDownload_DownloadType_name, RemoteDownload_DownloadType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for System service

type SystemClient interface {
	// Ping executes the ping command on the target and streams back
	// the results.  Some targets may not stream any results until all
	// results are in.  If a packet count is not explicitly provided,
	// 5 is used.
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (System_PingClient, error)
	// Traceroute executes the traceroute command on the target and streams back
	// the results.  Some targets may not stream any results until all
	// results are in.  If a hop count is not explicitly provided,
	// 30 is used.
	Traceroute(ctx context.Context, in *TracerouteRequest, opts ...grpc.CallOption) (System_TracerouteClient, error)
	// Time returns the current time on the target.  Time is typically used to
	// test if a target is actually responding.
	Time(ctx context.Context, in *TimeRequest, opts ...grpc.CallOption) (*TimeResponse, error)
	// SetPackage places a software package (possibly including bootable images)
	// on the target. The file is sent in sequential messages, each message
	// up to 64KB of data. A final message must be sent that includes the hash
	// of the data sent. An error is returned if the location does not exist or
	// there is an error writing the data. If no checksum is received, the target
	// must assume the operation is incomplete and remove the partially
	// transmitted file. The target should initially write the file to a temporary
	// location so a failure does not destroy the original file.
	SetPackage(ctx context.Context, opts ...grpc.CallOption) (System_SetPackageClient, error)
	// SwitchControlProcessor will switch from the current route processor to the
	// provided route processor. If the current route processor is the same as the
	// one provided it is a NOOP. If the target does not exist an error is
	// returned.
	SwitchControlProcessor(ctx context.Context, in *SwitchControlProcessorRequest, opts ...grpc.CallOption) (*SwitchControlProcessorResponse, error)
	// Reboot causes the target to reboot, possibly at some point in the future.
	// If the method of reboot is not supported then the Reboot RPC will fail.
	// If the reboot is immediate the command will block until the subcomponents
	// have restarted.
	// If a reboot on the active control processor is pending the service must
	// reject all other reboot requests.
	// If a reboot request for active control processor is initiated with other
	// pending reboot requests it must be rejected.
	Reboot(ctx context.Context, in *RebootRequest, opts ...grpc.CallOption) (*RebootResponse, error)
	// RebootStatus returns the status of reboot for the target.
	RebootStatus(ctx context.Context, in *RebootStatusRequest, opts ...grpc.CallOption) (*RebootStatusResponse, error)
	// CancelReboot cancels any pending reboot request.
	CancelReboot(ctx context.Context, in *CancelRebootRequest, opts ...grpc.CallOption) (*CancelRebootResponse, error)
}

type systemClient struct {
	cc *grpc.ClientConn
}

func NewSystemClient(cc *grpc.ClientConn) SystemClient {
	return &systemClient{cc}
}

func (c *systemClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (System_PingClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_System_serviceDesc.Streams[0], c.cc, "/gnoi.system.System/Ping", opts...)
	if err != nil {
		return nil, err
	}
	x := &systemPingClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type System_PingClient interface {
	Recv() (*PingResponse, error)
	grpc.ClientStream
}

type systemPingClient struct {
	grpc.ClientStream
}

func (x *systemPingClient) Recv() (*PingResponse, error) {
	m := new(PingResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *systemClient) Traceroute(ctx context.Context, in *TracerouteRequest, opts ...grpc.CallOption) (System_TracerouteClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_System_serviceDesc.Streams[1], c.cc, "/gnoi.system.System/Traceroute", opts...)
	if err != nil {
		return nil, err
	}
	x := &systemTracerouteClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type System_TracerouteClient interface {
	Recv() (*TracerouteResponse, error)
	grpc.ClientStream
}

type systemTracerouteClient struct {
	grpc.ClientStream
}

func (x *systemTracerouteClient) Recv() (*TracerouteResponse, error) {
	m := new(TracerouteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *systemClient) Time(ctx context.Context, in *TimeRequest, opts ...grpc.CallOption) (*TimeResponse, error) {
	out := new(TimeResponse)
	err := grpc.Invoke(ctx, "/gnoi.system.System/Time", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemClient) SetPackage(ctx context.Context, opts ...grpc.CallOption) (System_SetPackageClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_System_serviceDesc.Streams[2], c.cc, "/gnoi.system.System/SetPackage", opts...)
	if err != nil {
		return nil, err
	}
	x := &systemSetPackageClient{stream}
	return x, nil
}

type System_SetPackageClient interface {
	Send(*SetPackageRequest) error
	CloseAndRecv() (*SetPackageResponse, error)
	grpc.ClientStream
}

type systemSetPackageClient struct {
	grpc.ClientStream
}

func (x *systemSetPackageClient) Send(m *SetPackageRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *systemSetPackageClient) CloseAndRecv() (*SetPackageResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(SetPackageResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *systemClient) SwitchControlProcessor(ctx context.Context, in *SwitchControlProcessorRequest, opts ...grpc.CallOption) (*SwitchControlProcessorResponse, error) {
	out := new(SwitchControlProcessorResponse)
	err := grpc.Invoke(ctx, "/gnoi.system.System/SwitchControlProcessor", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemClient) Reboot(ctx context.Context, in *RebootRequest, opts ...grpc.CallOption) (*RebootResponse, error) {
	out := new(RebootResponse)
	err := grpc.Invoke(ctx, "/gnoi.system.System/Reboot", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemClient) RebootStatus(ctx context.Context, in *RebootStatusRequest, opts ...grpc.CallOption) (*RebootStatusResponse, error) {
	out := new(RebootStatusResponse)
	err := grpc.Invoke(ctx, "/gnoi.system.System/RebootStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemClient) CancelReboot(ctx context.Context, in *CancelRebootRequest, opts ...grpc.CallOption) (*CancelRebootResponse, error) {
	out := new(CancelRebootResponse)
	err := grpc.Invoke(ctx, "/gnoi.system.System/CancelReboot", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for System service

type SystemServer interface {
	// Ping executes the ping command on the target and streams back
	// the results.  Some targets may not stream any results until all
	// results are in.  If a packet count is not explicitly provided,
	// 5 is used.
	Ping(*PingRequest, System_PingServer) error
	// Traceroute executes the traceroute command on the target and streams back
	// the results.  Some targets may not stream any results until all
	// results are in.  If a hop count is not explicitly provided,
	// 30 is used.
	Traceroute(*TracerouteRequest, System_TracerouteServer) error
	// Time returns the current time on the target.  Time is typically used to
	// test if a target is actually responding.
	Time(context.Context, *TimeRequest) (*TimeResponse, error)
	// SetPackage places a software package (possibly including bootable images)
	// on the target. The file is sent in sequential messages, each message
	// up to 64KB of data. A final message must be sent that includes the hash
	// of the data sent. An error is returned if the location does not exist or
	// there is an error writing the data. If no checksum is received, the target
	// must assume the operation is incomplete and remove the partially
	// transmitted file. The target should initially write the file to a temporary
	// location so a failure does not destroy the original file.
	SetPackage(System_SetPackageServer) error
	// SwitchControlProcessor will switch from the current route processor to the
	// provided route processor. If the current route processor is the same as the
	// one provided it is a NOOP. If the target does not exist an error is
	// returned.
	SwitchControlProcessor(context.Context, *SwitchControlProcessorRequest) (*SwitchControlProcessorResponse, error)
	// Reboot causes the target to reboot, possibly at some point in the future.
	// If the method of reboot is not supported then the Reboot RPC will fail.
	// If the reboot is immediate the command will block until the subcomponents
	// have restarted.
	// If a reboot on the active control processor is pending the service must
	// reject all other reboot requests.
	// If a reboot request for active control processor is initiated with other
	// pending reboot requests it must be rejected.
	Reboot(context.Context, *RebootRequest) (*RebootResponse, error)
	// RebootStatus returns the status of reboot for the target.
	RebootStatus(context.Context, *RebootStatusRequest) (*RebootStatusResponse, error)
	// CancelReboot cancels any pending reboot request.
	CancelReboot(context.Context, *CancelRebootRequest) (*CancelRebootResponse, error)
}

func RegisterSystemServer(s *grpc.Server, srv SystemServer) {
	s.RegisterService(&_System_serviceDesc, srv)
}

func _System_Ping_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PingRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SystemServer).Ping(m, &systemPingServer{stream})
}

type System_PingServer interface {
	Send(*PingResponse) error
	grpc.ServerStream
}

type systemPingServer struct {
	grpc.ServerStream
}

func (x *systemPingServer) Send(m *PingResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _System_Traceroute_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TracerouteRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SystemServer).Traceroute(m, &systemTracerouteServer{stream})
}

type System_TracerouteServer interface {
	Send(*TracerouteResponse) error
	grpc.ServerStream
}

type systemTracerouteServer struct {
	grpc.ServerStream
}

func (x *systemTracerouteServer) Send(m *TracerouteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _System_Time_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServer).Time(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gnoi.system.System/Time",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServer).Time(ctx, req.(*TimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _System_SetPackage_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SystemServer).SetPackage(&systemSetPackageServer{stream})
}

type System_SetPackageServer interface {
	SendAndClose(*SetPackageResponse) error
	Recv() (*SetPackageRequest, error)
	grpc.ServerStream
}

type systemSetPackageServer struct {
	grpc.ServerStream
}

func (x *systemSetPackageServer) SendAndClose(m *SetPackageResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *systemSetPackageServer) Recv() (*SetPackageRequest, error) {
	m := new(SetPackageRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _System_SwitchControlProcessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwitchControlProcessorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServer).SwitchControlProcessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gnoi.system.System/SwitchControlProcessor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServer).SwitchControlProcessor(ctx, req.(*SwitchControlProcessorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _System_Reboot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RebootRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServer).Reboot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gnoi.system.System/Reboot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServer).Reboot(ctx, req.(*RebootRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _System_RebootStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RebootStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServer).RebootStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gnoi.system.System/RebootStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServer).RebootStatus(ctx, req.(*RebootStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _System_CancelReboot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelRebootRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServer).CancelReboot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gnoi.system.System/CancelReboot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServer).CancelReboot(ctx, req.(*CancelRebootRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _System_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gnoi.system.System",
	HandlerType: (*SystemServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Time",
			Handler:    _System_Time_Handler,
		},
		{
			MethodName: "SwitchControlProcessor",
			Handler:    _System_SwitchControlProcessor_Handler,
		},
		{
			MethodName: "Reboot",
			Handler:    _System_Reboot_Handler,
		},
		{
			MethodName: "RebootStatus",
			Handler:    _System_RebootStatus_Handler,
		},
		{
			MethodName: "CancelReboot",
			Handler:    _System_CancelReboot_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Ping",
			Handler:       _System_Ping_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Traceroute",
			Handler:       _System_Traceroute_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SetPackage",
			Handler:       _System_SetPackage_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "system/system.proto",
}

func init() { proto.RegisterFile("system/system.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1666 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0xcd, 0x6e, 0xe3, 0xc8,
	0x11, 0x16, 0xf5, 0xaf, 0x92, 0xed, 0xa1, 0xdb, 0xce, 0x2c, 0x47, 0x93, 0xec, 0x3a, 0xc4, 0x26,
	0xf0, 0x6c, 0x10, 0x79, 0xe2, 0x59, 0x60, 0x83, 0x2c, 0x16, 0x81, 0x46, 0xa2, 0x57, 0xc6, 0xca,
	0x92, 0xd2, 0xa2, 0x32, 0x41, 0x2e, 0x04, 0x4d, 0xf5, 0x48, 0xc4, 0x50, 0x6c, 0x85, 0xdd, 0xd2,
	0xac, 0x73, 0xce, 0x2d, 0x97, 0x1c, 0x82, 0x20, 0xd7, 0x7d, 0x8d, 0xbc, 0x48, 0x9e, 0x22, 0x97,
	0x3c, 0x41, 0xd0, 0x3f, 0x94, 0x28, 0x59, 0x63, 0x0f, 0x72, 0x52, 0xd7, 0x4f, 0x57, 0x57, 0x7d,
	0xf5, 0x75, 0xab, 0x08, 0x27, 0xec, 0x8e, 0x71, 0x32, 0xbf, 0x50, 0x3f, 0xcd, 0x45, 0x42, 0x39,
	0x45, 0xf5, 0x69, 0x4c, 0xc3, 0xa6, 0x52, 0x35, 0xea, 0xfc, 0x6e, 0x41, 0x98, 0xb2, 0xd8, 0x7f,
	0x80, 0x9f, 0x8c, 0xde, 0x87, 0x3c, 0x98, 0xb5, 0x69, 0xcc, 0x13, 0x1a, 0x0d, 0x13, 0x1a, 0x10,
	0xc6, 0x68, 0x82, 0xc9, 0x9f, 0x96, 0x84, 0x71, 0xf4, 0x15, 0x1c, 0x07, 0xca, 0xe4, 0x2d, 0x52,
	0x9b, 0x65, 0x9c, 0x19, 0xe7, 0xf5, 0x4b, 0x68, 0xca, 0xb0, 0x43, 0x9f, 0xcf, 0xb0, 0x19, 0xec,
	0xec, 0xb7, 0xff, 0x6a, 0xc0, 0xa7, 0x1f, 0x0a, 0xcd, 0x16, 0x34, 0x66, 0xe4, 0xff, 0x8e, 0x8d,
	0x2c, 0xa8, 0xac, 0x48, 0xc2, 0x42, 0x1a, 0x5b, 0xf9, 0x33, 0xe3, 0xbc, 0x86, 0x53, 0x11, 0x3d,
	0x85, 0xf2, 0x72, 0xc1, 0xc3, 0x39, 0xb1, 0x0a, 0x67, 0xc6, 0x79, 0x01, 0x6b, 0xc9, 0xfe, 0x97,
	0x01, 0x87, 0x98, 0xdc, 0x52, 0xca, 0xd3, 0xc2, 0x7e, 0x05, 0xe5, 0x39, 0xe1, 0x33, 0x3a, 0x91,
	0x27, 0x1e, 0x5d, 0x3e, 0x6b, 0x66, 0x40, 0x6a, 0x2a, 0xdf, 0x1b, 0xe9, 0x80, 0xb5, 0x23, 0x3a,
	0x85, 0xd2, 0x84, 0x44, 0xfe, 0x9d, 0x3c, 0xb4, 0x88, 0x95, 0x20, 0x92, 0x99, 0x13, 0xc6, 0xfc,
	0xa9, 0x3a, 0xb3, 0x86, 0x53, 0x11, 0xbd, 0x84, 0x43, 0xb6, 0xbc, 0x0d, 0xe8, 0x7c, 0x41, 0x63,
	0x12, 0x73, 0x66, 0x15, 0xcf, 0x0a, 0x3b, 0xb5, 0x6d, 0x3b, 0x88, 0x13, 0xde, 0xd2, 0x24, 0x20,
	0x56, 0xe9, 0xcc, 0x38, 0xaf, 0x62, 0x25, 0xd8, 0x26, 0x1c, 0xa5, 0xb9, 0x2b, 0xe4, 0x6c, 0x1f,
	0x4e, 0xda, 0x7e, 0x1c, 0x90, 0x68, 0xbb, 0xa6, 0x4c, 0x2a, 0xc6, 0x23, 0xa9, 0xe4, 0x1f, 0x49,
	0xc5, 0x7e, 0x0a, 0xa7, 0xdb, 0x47, 0xe8, 0xa3, 0xbf, 0x85, 0x13, 0xa5, 0x19, 0x71, 0x9f, 0x2f,
	0x59, 0x7a, 0xf4, 0xbd, 0x03, 0x8c, 0xc7, 0x0e, 0xf8, 0x8b, 0x01, 0xa7, 0xdb, 0x91, 0x34, 0x2d,
	0x9e, 0x42, 0xd9, 0x0f, 0x78, 0xb8, 0x52, 0x45, 0x54, 0xb1, 0x96, 0x10, 0x82, 0xe2, 0x7b, 0x3f,
	0xe4, 0x1a, 0x7d, 0xb9, 0x96, 0xba, 0x19, 0x89, 0x25, 0xf2, 0x42, 0x37, 0x23, 0x92, 0x03, 0x09,
	0xf1, 0x19, 0x8d, 0xad, 0xa2, 0x04, 0x41, 0x4b, 0x02, 0xdc, 0x80, 0x2e, 0x63, 0x2e, 0xc1, 0x3d,
	0xc4, 0x4a, 0xb0, 0x0f, 0xa1, 0xee, 0x86, 0x73, 0xa2, 0xeb, 0xb0, 0x6d, 0x38, 0x50, 0xa2, 0x4e,
	0x06, 0x41, 0x51, 0xd2, 0xc9, 0x50, 0x07, 0x48, 0x32, 0xfd, 0x90, 0x87, 0xfa, 0x30, 0x8c, 0xa7,
	0x69, 0xed, 0x67, 0x50, 0x9f, 0x10, 0xc6, 0xc3, 0xd8, 0xe7, 0x82, 0x92, 0x0a, 0xfa, 0xac, 0x4a,
	0xa4, 0xc4, 0xe8, 0x52, 0x34, 0x56, 0xf1, 0x55, 0x4b, 0x9b, 0x94, 0x44, 0xfe, 0x25, 0x9d, 0x12,
	0x6a, 0x40, 0x35, 0x8c, 0x39, 0x49, 0x56, 0x7e, 0x24, 0x4b, 0x28, 0xe0, 0xb5, 0xbc, 0x06, 0xa1,
	0x24, 0xf5, 0x6b, 0x10, 0x58, 0xf8, 0x67, 0x62, 0x95, 0x65, 0x10, 0xb9, 0x46, 0x3f, 0x87, 0x27,
	0x13, 0xea, 0xc5, 0x94, 0x7b, 0x6f, 0x13, 0x7f, 0x3a, 0x27, 0x31, 0xb7, 0x2a, 0x12, 0xcd, 0xc3,
	0x09, 0xed, 0x53, 0x7e, 0xa5, 0x95, 0xe8, 0x73, 0x38, 0xd2, 0x7e, 0x09, 0x61, 0x34, 0x5a, 0x11,
	0xab, 0x2a, 0xdd, 0x0e, 0xa4, 0x1b, 0x56, 0x3a, 0xf4, 0x12, 0x20, 0x7a, 0x25, 0x5f, 0x8c, 0x80,
	0x46, 0x56, 0x4d, 0x5e, 0x18, 0x53, 0xb5, 0xb6, 0xf7, 0x6a, 0xa8, 0xf5, 0x38, 0xe3, 0x63, 0xff,
	0x33, 0x0f, 0x07, 0x0a, 0xa3, 0x4d, 0x57, 0x35, 0x04, 0xc6, 0x16, 0x04, 0x29, 0xc0, 0x79, 0x55,
	0x90, 0x58, 0xcb, 0x82, 0xc8, 0x1a, 0x15, 0xb9, 0x16, 0xa0, 0x24, 0x24, 0x20, 0xe1, 0x8a, 0x4c,
	0x24, 0x28, 0x25, 0xbc, 0x96, 0xd1, 0x33, 0xa8, 0xce, 0xc3, 0xd8, 0x93, 0x71, 0x14, 0x30, 0x95,
	0x79, 0x18, 0x8b, 0x3e, 0x0a, 0x93, 0xbf, 0x9a, 0x2a, 0x53, 0x59, 0x99, 0xfc, 0xd5, 0x34, 0x35,
	0xcd, 0xfd, 0xef, 0x95, 0xa9, 0xa2, 0x77, 0xf9, 0xdf, 0x4b, 0xd3, 0x27, 0x50, 0x61, 0x7c, 0xe2,
	0x4d, 0xc8, 0x4a, 0xc2, 0x51, 0xc0, 0x65, 0xc6, 0x27, 0x1d, 0xb2, 0x12, 0x0d, 0xbb, 0xbd, 0xe3,
	0x84, 0x59, 0x75, 0xd5, 0x30, 0x29, 0x88, 0xdc, 0x98, 0xe0, 0x42, 0x1c, 0x10, 0xeb, 0x40, 0xe5,
	0x96, 0xca, 0xc8, 0x84, 0x02, 0xe7, 0x91, 0x75, 0x28, 0xd5, 0x62, 0x69, 0xff, 0xad, 0x00, 0xc7,
	0x6e, 0xe2, 0x07, 0x24, 0xa1, 0x4b, 0x9e, 0x12, 0xef, 0x83, 0xf8, 0xec, 0x90, 0x2b, 0x7f, 0x9f,
	0x5c, 0x9f, 0x41, 0x3d, 0x8c, 0x43, 0x1e, 0xfa, 0x91, 0x27, 0x4e, 0x2a, 0x48, 0x76, 0x83, 0x56,
	0xb9, 0x3c, 0x12, 0xd5, 0xc8, 0x42, 0x79, 0xa4, 0x91, 0x2b, 0x8b, 0x3a, 0xf9, 0x7e, 0x32, 0xed,
	0x21, 0x4e, 0xf9, 0xe3, 0x88, 0x53, 0x79, 0x94, 0x38, 0xd5, 0xc7, 0x89, 0x83, 0xae, 0x01, 0xa2,
	0x2f, 0x77, 0xa8, 0xf6, 0x62, 0xeb, 0x6d, 0xbe, 0x87, 0x5d, 0xb3, 0xf7, 0x65, 0x26, 0xd4, 0x7a,
	0xb3, 0x7d, 0x0e, 0xb0, 0xb1, 0xa0, 0x2a, 0x14, 0xaf, 0xdb, 0x37, 0x43, 0x33, 0x87, 0x2a, 0x50,
	0x70, 0xdb, 0x43, 0xd3, 0x10, 0x8b, 0x71, 0x67, 0x68, 0xe6, 0xed, 0x7f, 0x97, 0x00, 0x65, 0xc3,
	0x6a, 0xce, 0xbe, 0x00, 0x33, 0x03, 0xb4, 0x17, 0xfb, 0xf3, 0xb4, 0x3b, 0x4f, 0x32, 0xfa, 0xbe,
	0x3f, 0x27, 0xe8, 0x02, 0x4e, 0xb2, 0xae, 0xfe, 0x64, 0x92, 0x10, 0xc6, 0x74, 0xbb, 0x50, 0xc6,
	0xd4, 0x52, 0x16, 0x81, 0xfd, 0x8c, 0x2e, 0x58, 0xca, 0x71, 0xb1, 0x16, 0x9d, 0x5c, 0xf8, 0xc1,
	0x3b, 0xc2, 0x3d, 0x79, 0x9f, 0x55, 0xb3, 0x40, 0xa9, 0x46, 0xe2, 0x56, 0x9b, 0x50, 0x98, 0xd1,
	0x85, 0xec, 0x57, 0x09, 0x8b, 0xa5, 0x78, 0xf2, 0xd3, 0xb3, 0xca, 0xea, 0xc9, 0xf7, 0x37, 0x07,
	0xc8, 0x84, 0x2b, 0x52, 0x2d, 0xd7, 0x62, 0x7f, 0xc2, 0xb9, 0xe6, 0xb4, 0x58, 0xa2, 0xaf, 0xa1,
	0xc4, 0xb8, 0xcf, 0x89, 0x46, 0xfa, 0x67, 0x1f, 0x44, 0x5a, 0x41, 0xd2, 0x14, 0x6f, 0x35, 0xc1,
	0x6a, 0x0f, 0x7a, 0x0e, 0xb5, 0x30, 0x98, 0x2f, 0xbc, 0x80, 0x4e, 0x88, 0x05, 0x8a, 0xf8, 0x42,
	0xd1, 0xa6, 0x13, 0x82, 0xbe, 0x81, 0xe2, 0x7c, 0x11, 0x89, 0x9b, 0x22, 0xfe, 0x08, 0x5e, 0x3c,
	0x16, 0xf8, 0x66, 0x11, 0x31, 0x27, 0xe6, 0xc9, 0x1d, 0x96, 0xdb, 0x04, 0x69, 0x7d, 0xe6, 0x2d,
	0x7c, 0x3e, 0xb3, 0x0e, 0xce, 0x0a, 0x82, 0xb4, 0x3e, 0x13, 0x7f, 0x23, 0x8d, 0xaf, 0xa0, 0xb6,
	0xf6, 0x15, 0x05, 0xbd, 0x23, 0x77, 0xba, 0x29, 0x62, 0x29, 0x6e, 0xe8, 0xca, 0x8f, 0x96, 0xe9,
	0x4b, 0xab, 0x84, 0xdf, 0xe4, 0x7f, 0x6d, 0xd8, 0xff, 0x35, 0xa0, 0x24, 0xd3, 0x47, 0x75, 0xa8,
	0x74, 0x9c, 0xab, 0xd6, 0xb8, 0xe7, 0x9a, 0x39, 0xc1, 0x8b, 0xfe, 0xa0, 0xef, 0x98, 0x86, 0x50,
	0x8f, 0xfb, 0xdf, 0xf5, 0x07, 0x6f, 0xfa, 0x66, 0x7e, 0x4d, 0x97, 0x02, 0x3a, 0x05, 0xb3, 0x3b,
	0x18, 0xb9, 0xde, 0xb8, 0x8f, 0x9d, 0x56, 0xbb, 0xdb, 0x7a, 0xdd, 0x73, 0xcc, 0x22, 0xfa, 0x04,
	0x4e, 0xfa, 0x8e, 0xfb, 0x66, 0x80, 0xbf, 0xdb, 0x32, 0x94, 0x90, 0x05, 0xa7, 0x43, 0x3c, 0x70,
	0x07, 0xed, 0x41, 0x6f, 0xcb, 0x52, 0x16, 0x5b, 0x46, 0x83, 0x31, 0x6e, 0x3b, 0x1e, 0x1e, 0x8c,
	0x5d, 0xc7, 0xbb, 0x6a, 0x5d, 0xf7, 0x9c, 0x8e, 0x59, 0x11, 0x5b, 0xae, 0x70, 0xeb, 0xdb, 0x1b,
	0xa7, 0xef, 0xb6, 0xdc, 0xeb, 0x41, 0xdf, 0xeb, 0x3b, 0x4e, 0xc7, 0xe9, 0x98, 0x55, 0x74, 0x04,
	0x30, 0xc4, 0x83, 0xee, 0xf5, 0xeb, 0x6b, 0xd7, 0xe9, 0x98, 0x35, 0x15, 0xdc, 0x69, 0x3b, 0x1d,
	0xa7, 0xdf, 0x76, 0xbc, 0xdf, 0x5f, 0x0f, 0x7a, 0x72, 0x83, 0x09, 0xe8, 0x47, 0x70, 0x9c, 0xb1,
	0xb4, 0xc7, 0xee, 0xe0, 0xea, 0xca, 0xac, 0xdb, 0xff, 0x31, 0xc4, 0xf0, 0x30, 0xa7, 0x9c, 0x74,
	0xe8, 0xfb, 0x38, 0xa2, 0xfe, 0x44, 0x10, 0x43, 0xc2, 0xaa, 0x40, 0x93, 0x6b, 0x74, 0x03, 0x87,
	0x13, 0x6d, 0xf7, 0xc4, 0x7c, 0x28, 0xd1, 0x3b, 0xba, 0x3c, 0xdf, 0x19, 0x8a, 0xb2, 0x71, 0x9a,
	0xe9, 0xc2, 0xbd, 0x5b, 0x10, 0x71, 0xed, 0x37, 0x12, 0x7a, 0x05, 0xf5, 0x20, 0x21, 0x13, 0x12,
	0x8b, 0x27, 0x48, 0x71, 0xbc, 0x7e, 0x79, 0xac, 0x82, 0xb5, 0x37, 0x06, 0x9c, 0xf5, 0xb2, 0xdb,
	0x70, 0x90, 0x0d, 0x99, 0x6d, 0x87, 0xec, 0xd2, 0xe8, 0xca, 0x15, 0x97, 0xb6, 0x0a, 0xc5, 0xae,
	0xeb, 0x0e, 0xcd, 0x3c, 0xaa, 0x41, 0x49, 0xac, 0x46, 0x66, 0x41, 0xdc, 0xe4, 0x51, 0x7b, 0x68,
	0x16, 0xed, 0x1f, 0x0c, 0xa8, 0x0c, 0xfd, 0xe0, 0x9d, 0x18, 0x7a, 0x1a, 0x50, 0x7d, 0x1b, 0x46,
	0x24, 0x73, 0x6d, 0xd7, 0x72, 0x76, 0x84, 0x2c, 0x6e, 0x8f, 0x90, 0x0d, 0xa8, 0xca, 0x81, 0x43,
	0x5c, 0x0a, 0x35, 0x86, 0xad, 0x65, 0xd4, 0x81, 0x27, 0x89, 0x04, 0xc1, 0x4b, 0xcb, 0x95, 0xb7,
	0xae, 0x7e, 0xf9, 0xfc, 0x01, 0xa0, 0xf0, 0x51, 0xb2, 0x25, 0xdb, 0x7f, 0x37, 0xe0, 0x78, 0x44,
	0xb8, 0x4e, 0x73, 0x33, 0x41, 0x55, 0x16, 0x4a, 0xa3, 0x67, 0xe0, 0xd3, 0xad, 0x98, 0xda, 0xbb,
	0x9b, 0xc3, 0xa9, 0x1b, 0xfa, 0x31, 0x54, 0xc5, 0x68, 0xac, 0xe7, 0x39, 0xe3, 0xfc, 0xa0, 0x9b,
	0xc3, 0x6b, 0x0d, 0xfa, 0x1c, 0x8a, 0x33, 0x9f, 0xcd, 0x34, 0xf8, 0x47, 0x2a, 0x58, 0xd7, 0x67,
	0x33, 0x01, 0x6e, 0x37, 0x87, 0xa5, 0xf5, 0x75, 0x0d, 0x2a, 0x89, 0x1e, 0x7d, 0x4e, 0x01, 0x65,
	0xb3, 0x52, 0xf7, 0xf2, 0x8b, 0x10, 0x0e, 0xb2, 0xc3, 0xf0, 0xbd, 0xae, 0xb4, 0x07, 0xbd, 0x8e,
	0x69, 0xa0, 0x43, 0xa8, 0x0d, 0x07, 0x6f, 0x1c, 0xdc, 0x59, 0xdf, 0x9e, 0x6e, 0xab, 0xe7, 0x9a,
	0x05, 0xb1, 0x7a, 0xd3, 0xc2, 0x37, 0x66, 0x51, 0xf4, 0xa8, 0x3f, 0xba, 0x32, 0x4b, 0xa2, 0x6f,
	0xd8, 0x19, 0x39, 0xae, 0x59, 0x16, 0xd1, 0xe4, 0xb6, 0xf1, 0xd0, 0xac, 0x5c, 0xfe, 0xa3, 0x04,
	0xe5, 0x91, 0xac, 0x16, 0xfd, 0x16, 0x8a, 0x62, 0x7a, 0x40, 0xd6, 0x36, 0x06, 0x9b, 0xa1, 0xab,
	0xf1, 0x6c, 0x8f, 0x45, 0x8f, 0xa8, 0xb9, 0x97, 0x06, 0xfa, 0x1d, 0xc0, 0xe6, 0x91, 0x41, 0x9f,
	0x3e, 0xfc, 0x07, 0xd2, 0xf8, 0xec, 0x91, 0xd7, 0x49, 0x86, 0xfc, 0x06, 0x8a, 0x72, 0x38, 0xd8,
	0xce, 0x29, 0x33, 0x3c, 0xee, 0xe4, 0x94, 0x9d, 0x23, 0xed, 0x9c, 0xc8, 0x68, 0x03, 0xef, 0x4e,
	0x46, 0xf7, 0xd8, 0xb0, 0x93, 0xd1, 0xfd, 0xbe, 0xd8, 0xb9, 0x73, 0x03, 0x31, 0x78, 0xba, 0xff,
	0x13, 0x0b, 0x7d, 0xb1, 0xbd, 0xfd, 0xa1, 0x4f, 0xbc, 0xc6, 0x2f, 0x3e, 0xca, 0x77, 0x5d, 0x47,
	0x1b, 0xca, 0x8a, 0x10, 0xa8, 0xb1, 0xe7, 0x93, 0x29, 0x0d, 0xfa, 0x7c, 0xaf, 0x6d, 0x1d, 0x64,
	0x9c, 0xb2, 0x4a, 0xcd, 0xfe, 0xe8, 0x6c, 0x8f, 0xfb, 0xd6, 0x07, 0x46, 0xe3, 0xa7, 0x0f, 0x78,
	0x64, 0xc3, 0x66, 0x3f, 0x5a, 0x76, 0xc2, 0xee, 0xf9, 0x64, 0xda, 0x09, 0xbb, 0xf7, 0x8b, 0x27,
	0xf7, 0xfa, 0xe2, 0x8f, 0xbf, 0x9c, 0x86, 0x7c, 0xb6, 0xbc, 0x6d, 0x06, 0x74, 0x7e, 0x41, 0x17,
	0x24, 0x0e, 0x68, 0xfc, 0x36, 0x9c, 0x5e, 0x88, 0xbd, 0xfa, 0x53, 0xfb, 0xeb, 0x4c, 0x9c, 0xdb,
	0xb2, 0x9c, 0x41, 0x5e, 0xfd, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x8a, 0x85, 0x95, 0xb6, 0x8e, 0x0f,
	0x00, 0x00,
}
