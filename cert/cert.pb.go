// Code generated by protoc-gen-go.
// source: cert/cert.proto
// DO NOT EDIT!

/*
Package gnoi_certificate is a generated protocol buffer package.

It is generated from these files:
	cert/cert.proto

It has these top-level messages:
	RotateCertificateRequest
	RotateCertificateResponse
	InstallCertificateRequest
	InstallCertificateResponse
	GenerateCSRRequest
	CSRParams
	GenerateCSRResponse
	LoadCertificateRequest
	LoadCertificateResponse
	FinalizeRequest
	GetCertificatesRequest
	GetCertificatesResponse
	CertificateInfo
	RevokeCertificatesRequest
	RevokeCertificatesResponse
	CertificateRevocationError
	CanGenerateCSRRequest
	CanGenerateCSRResponse
	Certificate
	CSR
	KeyPair
	Endpoint
*/
package gnoi_certificate

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Types of certificates.
type CertificateType int32

const (
	// 1 - 500 for public use.
	// 501 onwards for private use.
	CertificateType_CT_UNKNOWN CertificateType = 0
	CertificateType_CT_X509    CertificateType = 1
)

var CertificateType_name = map[int32]string{
	0: "CT_UNKNOWN",
	1: "CT_X509",
}
var CertificateType_value = map[string]int32{
	"CT_UNKNOWN": 0,
	"CT_X509":    1,
}

func (x CertificateType) String() string {
	return proto.EnumName(CertificateType_name, int32(x))
}
func (CertificateType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Algorithm to be used for generation the key pair.
type KeyType int32

const (
	// 1 - 500, for known types.
	// 501 and onwards for private use.
	KeyType_KT_UNKNOWN KeyType = 0
	KeyType_KT_RSA     KeyType = 1
)

var KeyType_name = map[int32]string{
	0: "KT_UNKNOWN",
	1: "KT_RSA",
}
var KeyType_value = map[string]int32{
	"KT_UNKNOWN": 0,
	"KT_RSA":     1,
}

func (x KeyType) String() string {
	return proto.EnumName(KeyType_name, int32(x))
}
func (KeyType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// Type of endpoint that can use a cert. This list is to be extended based on
// conversation with vendors.
type Endpoint_Type int32

const (
	Endpoint_EP_UNSPECIFIED  Endpoint_Type = 0
	Endpoint_EP_IPSEC_TUNNEL Endpoint_Type = 1
	Endpoint_EP_DAEMON       Endpoint_Type = 2
)

var Endpoint_Type_name = map[int32]string{
	0: "EP_UNSPECIFIED",
	1: "EP_IPSEC_TUNNEL",
	2: "EP_DAEMON",
}
var Endpoint_Type_value = map[string]int32{
	"EP_UNSPECIFIED":  0,
	"EP_IPSEC_TUNNEL": 1,
	"EP_DAEMON":       2,
}

func (x Endpoint_Type) String() string {
	return proto.EnumName(Endpoint_Type_name, int32(x))
}
func (Endpoint_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{21, 0} }

// Request messages to rotate existing certificates on the target.
type RotateCertificateRequest struct {
	// Request Messages.
	//
	// Types that are valid to be assigned to RotateRequest:
	//	*RotateCertificateRequest_GenerateCsr
	//	*RotateCertificateRequest_LoadCertificate
	//	*RotateCertificateRequest_FinalizeRotation
	RotateRequest isRotateCertificateRequest_RotateRequest `protobuf_oneof:"rotate_request"`
}

func (m *RotateCertificateRequest) Reset()                    { *m = RotateCertificateRequest{} }
func (m *RotateCertificateRequest) String() string            { return proto.CompactTextString(m) }
func (*RotateCertificateRequest) ProtoMessage()               {}
func (*RotateCertificateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type isRotateCertificateRequest_RotateRequest interface {
	isRotateCertificateRequest_RotateRequest()
}

type RotateCertificateRequest_GenerateCsr struct {
	GenerateCsr *GenerateCSRRequest `protobuf:"bytes,1,opt,name=generate_csr,json=generateCsr,oneof"`
}
type RotateCertificateRequest_LoadCertificate struct {
	LoadCertificate *LoadCertificateRequest `protobuf:"bytes,2,opt,name=load_certificate,json=loadCertificate,oneof"`
}
type RotateCertificateRequest_FinalizeRotation struct {
	FinalizeRotation *FinalizeRequest `protobuf:"bytes,3,opt,name=finalize_rotation,json=finalizeRotation,oneof"`
}

func (*RotateCertificateRequest_GenerateCsr) isRotateCertificateRequest_RotateRequest()      {}
func (*RotateCertificateRequest_LoadCertificate) isRotateCertificateRequest_RotateRequest()  {}
func (*RotateCertificateRequest_FinalizeRotation) isRotateCertificateRequest_RotateRequest() {}

func (m *RotateCertificateRequest) GetRotateRequest() isRotateCertificateRequest_RotateRequest {
	if m != nil {
		return m.RotateRequest
	}
	return nil
}

func (m *RotateCertificateRequest) GetGenerateCsr() *GenerateCSRRequest {
	if x, ok := m.GetRotateRequest().(*RotateCertificateRequest_GenerateCsr); ok {
		return x.GenerateCsr
	}
	return nil
}

func (m *RotateCertificateRequest) GetLoadCertificate() *LoadCertificateRequest {
	if x, ok := m.GetRotateRequest().(*RotateCertificateRequest_LoadCertificate); ok {
		return x.LoadCertificate
	}
	return nil
}

func (m *RotateCertificateRequest) GetFinalizeRotation() *FinalizeRequest {
	if x, ok := m.GetRotateRequest().(*RotateCertificateRequest_FinalizeRotation); ok {
		return x.FinalizeRotation
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RotateCertificateRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RotateCertificateRequest_OneofMarshaler, _RotateCertificateRequest_OneofUnmarshaler, _RotateCertificateRequest_OneofSizer, []interface{}{
		(*RotateCertificateRequest_GenerateCsr)(nil),
		(*RotateCertificateRequest_LoadCertificate)(nil),
		(*RotateCertificateRequest_FinalizeRotation)(nil),
	}
}

func _RotateCertificateRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RotateCertificateRequest)
	// rotate_request
	switch x := m.RotateRequest.(type) {
	case *RotateCertificateRequest_GenerateCsr:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GenerateCsr); err != nil {
			return err
		}
	case *RotateCertificateRequest_LoadCertificate:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LoadCertificate); err != nil {
			return err
		}
	case *RotateCertificateRequest_FinalizeRotation:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FinalizeRotation); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RotateCertificateRequest.RotateRequest has unexpected type %T", x)
	}
	return nil
}

func _RotateCertificateRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RotateCertificateRequest)
	switch tag {
	case 1: // rotate_request.generate_csr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GenerateCSRRequest)
		err := b.DecodeMessage(msg)
		m.RotateRequest = &RotateCertificateRequest_GenerateCsr{msg}
		return true, err
	case 2: // rotate_request.load_certificate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoadCertificateRequest)
		err := b.DecodeMessage(msg)
		m.RotateRequest = &RotateCertificateRequest_LoadCertificate{msg}
		return true, err
	case 3: // rotate_request.finalize_rotation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FinalizeRequest)
		err := b.DecodeMessage(msg)
		m.RotateRequest = &RotateCertificateRequest_FinalizeRotation{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RotateCertificateRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RotateCertificateRequest)
	// rotate_request
	switch x := m.RotateRequest.(type) {
	case *RotateCertificateRequest_GenerateCsr:
		s := proto.Size(x.GenerateCsr)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RotateCertificateRequest_LoadCertificate:
		s := proto.Size(x.LoadCertificate)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RotateCertificateRequest_FinalizeRotation:
		s := proto.Size(x.FinalizeRotation)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Response Messages from the target.
type RotateCertificateResponse struct {
	// Response messages.
	//
	// Types that are valid to be assigned to RotateResponse:
	//	*RotateCertificateResponse_GeneratedCsr
	//	*RotateCertificateResponse_LoadCertificate
	RotateResponse isRotateCertificateResponse_RotateResponse `protobuf_oneof:"rotate_response"`
}

func (m *RotateCertificateResponse) Reset()                    { *m = RotateCertificateResponse{} }
func (m *RotateCertificateResponse) String() string            { return proto.CompactTextString(m) }
func (*RotateCertificateResponse) ProtoMessage()               {}
func (*RotateCertificateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isRotateCertificateResponse_RotateResponse interface {
	isRotateCertificateResponse_RotateResponse()
}

type RotateCertificateResponse_GeneratedCsr struct {
	GeneratedCsr *GenerateCSRResponse `protobuf:"bytes,1,opt,name=generated_csr,json=generatedCsr,oneof"`
}
type RotateCertificateResponse_LoadCertificate struct {
	LoadCertificate *LoadCertificateResponse `protobuf:"bytes,2,opt,name=load_certificate,json=loadCertificate,oneof"`
}

func (*RotateCertificateResponse_GeneratedCsr) isRotateCertificateResponse_RotateResponse()    {}
func (*RotateCertificateResponse_LoadCertificate) isRotateCertificateResponse_RotateResponse() {}

func (m *RotateCertificateResponse) GetRotateResponse() isRotateCertificateResponse_RotateResponse {
	if m != nil {
		return m.RotateResponse
	}
	return nil
}

func (m *RotateCertificateResponse) GetGeneratedCsr() *GenerateCSRResponse {
	if x, ok := m.GetRotateResponse().(*RotateCertificateResponse_GeneratedCsr); ok {
		return x.GeneratedCsr
	}
	return nil
}

func (m *RotateCertificateResponse) GetLoadCertificate() *LoadCertificateResponse {
	if x, ok := m.GetRotateResponse().(*RotateCertificateResponse_LoadCertificate); ok {
		return x.LoadCertificate
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RotateCertificateResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RotateCertificateResponse_OneofMarshaler, _RotateCertificateResponse_OneofUnmarshaler, _RotateCertificateResponse_OneofSizer, []interface{}{
		(*RotateCertificateResponse_GeneratedCsr)(nil),
		(*RotateCertificateResponse_LoadCertificate)(nil),
	}
}

func _RotateCertificateResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RotateCertificateResponse)
	// rotate_response
	switch x := m.RotateResponse.(type) {
	case *RotateCertificateResponse_GeneratedCsr:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GeneratedCsr); err != nil {
			return err
		}
	case *RotateCertificateResponse_LoadCertificate:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LoadCertificate); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RotateCertificateResponse.RotateResponse has unexpected type %T", x)
	}
	return nil
}

func _RotateCertificateResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RotateCertificateResponse)
	switch tag {
	case 1: // rotate_response.generated_csr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GenerateCSRResponse)
		err := b.DecodeMessage(msg)
		m.RotateResponse = &RotateCertificateResponse_GeneratedCsr{msg}
		return true, err
	case 2: // rotate_response.load_certificate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoadCertificateResponse)
		err := b.DecodeMessage(msg)
		m.RotateResponse = &RotateCertificateResponse_LoadCertificate{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RotateCertificateResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RotateCertificateResponse)
	// rotate_response
	switch x := m.RotateResponse.(type) {
	case *RotateCertificateResponse_GeneratedCsr:
		s := proto.Size(x.GeneratedCsr)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RotateCertificateResponse_LoadCertificate:
		s := proto.Size(x.LoadCertificate)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Request messages to install new certificates on the target.
type InstallCertificateRequest struct {
	// Request Messages.
	//
	// Types that are valid to be assigned to InstallRequest:
	//	*InstallCertificateRequest_GenerateCsr
	//	*InstallCertificateRequest_LoadCertificate
	InstallRequest isInstallCertificateRequest_InstallRequest `protobuf_oneof:"install_request"`
}

func (m *InstallCertificateRequest) Reset()                    { *m = InstallCertificateRequest{} }
func (m *InstallCertificateRequest) String() string            { return proto.CompactTextString(m) }
func (*InstallCertificateRequest) ProtoMessage()               {}
func (*InstallCertificateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type isInstallCertificateRequest_InstallRequest interface {
	isInstallCertificateRequest_InstallRequest()
}

type InstallCertificateRequest_GenerateCsr struct {
	GenerateCsr *GenerateCSRRequest `protobuf:"bytes,1,opt,name=generate_csr,json=generateCsr,oneof"`
}
type InstallCertificateRequest_LoadCertificate struct {
	LoadCertificate *LoadCertificateRequest `protobuf:"bytes,2,opt,name=load_certificate,json=loadCertificate,oneof"`
}

func (*InstallCertificateRequest_GenerateCsr) isInstallCertificateRequest_InstallRequest()     {}
func (*InstallCertificateRequest_LoadCertificate) isInstallCertificateRequest_InstallRequest() {}

func (m *InstallCertificateRequest) GetInstallRequest() isInstallCertificateRequest_InstallRequest {
	if m != nil {
		return m.InstallRequest
	}
	return nil
}

func (m *InstallCertificateRequest) GetGenerateCsr() *GenerateCSRRequest {
	if x, ok := m.GetInstallRequest().(*InstallCertificateRequest_GenerateCsr); ok {
		return x.GenerateCsr
	}
	return nil
}

func (m *InstallCertificateRequest) GetLoadCertificate() *LoadCertificateRequest {
	if x, ok := m.GetInstallRequest().(*InstallCertificateRequest_LoadCertificate); ok {
		return x.LoadCertificate
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InstallCertificateRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InstallCertificateRequest_OneofMarshaler, _InstallCertificateRequest_OneofUnmarshaler, _InstallCertificateRequest_OneofSizer, []interface{}{
		(*InstallCertificateRequest_GenerateCsr)(nil),
		(*InstallCertificateRequest_LoadCertificate)(nil),
	}
}

func _InstallCertificateRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InstallCertificateRequest)
	// install_request
	switch x := m.InstallRequest.(type) {
	case *InstallCertificateRequest_GenerateCsr:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GenerateCsr); err != nil {
			return err
		}
	case *InstallCertificateRequest_LoadCertificate:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LoadCertificate); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("InstallCertificateRequest.InstallRequest has unexpected type %T", x)
	}
	return nil
}

func _InstallCertificateRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InstallCertificateRequest)
	switch tag {
	case 1: // install_request.generate_csr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GenerateCSRRequest)
		err := b.DecodeMessage(msg)
		m.InstallRequest = &InstallCertificateRequest_GenerateCsr{msg}
		return true, err
	case 2: // install_request.load_certificate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoadCertificateRequest)
		err := b.DecodeMessage(msg)
		m.InstallRequest = &InstallCertificateRequest_LoadCertificate{msg}
		return true, err
	default:
		return false, nil
	}
}

func _InstallCertificateRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InstallCertificateRequest)
	// install_request
	switch x := m.InstallRequest.(type) {
	case *InstallCertificateRequest_GenerateCsr:
		s := proto.Size(x.GenerateCsr)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InstallCertificateRequest_LoadCertificate:
		s := proto.Size(x.LoadCertificate)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Response Messages from the target for the InstallCertificateRequest.
type InstallCertificateResponse struct {
	// Response messages.
	//
	// Types that are valid to be assigned to InstallResponse:
	//	*InstallCertificateResponse_GeneratedCsr
	//	*InstallCertificateResponse_LoadCertificate
	InstallResponse isInstallCertificateResponse_InstallResponse `protobuf_oneof:"install_response"`
}

func (m *InstallCertificateResponse) Reset()                    { *m = InstallCertificateResponse{} }
func (m *InstallCertificateResponse) String() string            { return proto.CompactTextString(m) }
func (*InstallCertificateResponse) ProtoMessage()               {}
func (*InstallCertificateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isInstallCertificateResponse_InstallResponse interface {
	isInstallCertificateResponse_InstallResponse()
}

type InstallCertificateResponse_GeneratedCsr struct {
	GeneratedCsr *GenerateCSRResponse `protobuf:"bytes,1,opt,name=generated_csr,json=generatedCsr,oneof"`
}
type InstallCertificateResponse_LoadCertificate struct {
	LoadCertificate *LoadCertificateResponse `protobuf:"bytes,2,opt,name=load_certificate,json=loadCertificate,oneof"`
}

func (*InstallCertificateResponse_GeneratedCsr) isInstallCertificateResponse_InstallResponse()    {}
func (*InstallCertificateResponse_LoadCertificate) isInstallCertificateResponse_InstallResponse() {}

func (m *InstallCertificateResponse) GetInstallResponse() isInstallCertificateResponse_InstallResponse {
	if m != nil {
		return m.InstallResponse
	}
	return nil
}

func (m *InstallCertificateResponse) GetGeneratedCsr() *GenerateCSRResponse {
	if x, ok := m.GetInstallResponse().(*InstallCertificateResponse_GeneratedCsr); ok {
		return x.GeneratedCsr
	}
	return nil
}

func (m *InstallCertificateResponse) GetLoadCertificate() *LoadCertificateResponse {
	if x, ok := m.GetInstallResponse().(*InstallCertificateResponse_LoadCertificate); ok {
		return x.LoadCertificate
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InstallCertificateResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InstallCertificateResponse_OneofMarshaler, _InstallCertificateResponse_OneofUnmarshaler, _InstallCertificateResponse_OneofSizer, []interface{}{
		(*InstallCertificateResponse_GeneratedCsr)(nil),
		(*InstallCertificateResponse_LoadCertificate)(nil),
	}
}

func _InstallCertificateResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InstallCertificateResponse)
	// install_response
	switch x := m.InstallResponse.(type) {
	case *InstallCertificateResponse_GeneratedCsr:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GeneratedCsr); err != nil {
			return err
		}
	case *InstallCertificateResponse_LoadCertificate:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LoadCertificate); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("InstallCertificateResponse.InstallResponse has unexpected type %T", x)
	}
	return nil
}

func _InstallCertificateResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InstallCertificateResponse)
	switch tag {
	case 1: // install_response.generated_csr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GenerateCSRResponse)
		err := b.DecodeMessage(msg)
		m.InstallResponse = &InstallCertificateResponse_GeneratedCsr{msg}
		return true, err
	case 2: // install_response.load_certificate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoadCertificateResponse)
		err := b.DecodeMessage(msg)
		m.InstallResponse = &InstallCertificateResponse_LoadCertificate{msg}
		return true, err
	default:
		return false, nil
	}
}

func _InstallCertificateResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InstallCertificateResponse)
	// install_response
	switch x := m.InstallResponse.(type) {
	case *InstallCertificateResponse_GeneratedCsr:
		s := proto.Size(x.GeneratedCsr)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InstallCertificateResponse_LoadCertificate:
		s := proto.Size(x.LoadCertificate)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Request to generate the CSR.
// When this request is made for rotating an existing certificate as part of the
// Rotate() RPC, then the target must ensure that the "certificate_id" is
// already created and exists on the target. If the Certificate Rotation
// proceeds to load the certificate, it must associate the new certificate with
// the previously created "certificate_id".
//
// When this request is made for installing a completely new certificate as part
// of the Install() RPC , then the target must ensure that the "certificate_id"
// is completely new and no entities on the target are should be bound to this
// certificate_id. If any existing certificate matches the certificate_id, then
// this request should fail.
//
// If there is another ongoing Rotate/Install RPC with the same certificate_id,
// the GenerateCSRRequest should fail.
type GenerateCSRRequest struct {
	// Parameters for creating a CSR.
	CsrParams *CSRParams `protobuf:"bytes,1,opt,name=csr_params,json=csrParams" json:"csr_params,omitempty"`
	// The certificate id with which this CSR will be associated. The target
	// configuration should bind an entity which wants to use a certificate to
	// the certificate_id it should use.
	CertificateId string `protobuf:"bytes,2,opt,name=certificate_id,json=certificateId" json:"certificate_id,omitempty"`
}

func (m *GenerateCSRRequest) Reset()                    { *m = GenerateCSRRequest{} }
func (m *GenerateCSRRequest) String() string            { return proto.CompactTextString(m) }
func (*GenerateCSRRequest) ProtoMessage()               {}
func (*GenerateCSRRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *GenerateCSRRequest) GetCsrParams() *CSRParams {
	if m != nil {
		return m.CsrParams
	}
	return nil
}

func (m *GenerateCSRRequest) GetCertificateId() string {
	if m != nil {
		return m.CertificateId
	}
	return ""
}

// Parameters to be used when generating a Certificate Signing Request.
type CSRParams struct {
	// The type of certificate which will be will be associated for this CSR.
	Type CertificateType `protobuf:"varint,1,opt,name=type,enum=gnoi.certificate.CertificateType" json:"type,omitempty"`
	// Minimum size of the key to be used by the target when generating a
	// public/private key pair.
	MinKeySize uint32 `protobuf:"varint,2,opt,name=min_key_size,json=minKeySize" json:"min_key_size,omitempty"`
	// If provided, the target must use the provided key type. If the target
	// cannot use the algorithm specified in the key_type, it should cancel the
	// stream with an Unimplemented error.
	KeyType KeyType `protobuf:"varint,3,opt,name=key_type,json=keyType,enum=gnoi.certificate.KeyType" json:"key_type,omitempty"`
	// --- common set of parameters applicable for any type of certificate --- //
	CommonName         string `protobuf:"bytes,4,opt,name=common_name,json=commonName" json:"common_name,omitempty"`
	Country            string `protobuf:"bytes,5,opt,name=country" json:"country,omitempty"`
	State              string `protobuf:"bytes,6,opt,name=state" json:"state,omitempty"`
	City               string `protobuf:"bytes,7,opt,name=city" json:"city,omitempty"`
	Organization       string `protobuf:"bytes,8,opt,name=organization" json:"organization,omitempty"`
	OrganizationalUnit string `protobuf:"bytes,9,opt,name=organizational_unit,json=organizationalUnit" json:"organizational_unit,omitempty"`
	IpAddress          string `protobuf:"bytes,10,opt,name=ip_address,json=ipAddress" json:"ip_address,omitempty"`
	EmailId            string `protobuf:"bytes,11,opt,name=email_id,json=emailId" json:"email_id,omitempty"`
}

func (m *CSRParams) Reset()                    { *m = CSRParams{} }
func (m *CSRParams) String() string            { return proto.CompactTextString(m) }
func (*CSRParams) ProtoMessage()               {}
func (*CSRParams) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *CSRParams) GetType() CertificateType {
	if m != nil {
		return m.Type
	}
	return CertificateType_CT_UNKNOWN
}

func (m *CSRParams) GetMinKeySize() uint32 {
	if m != nil {
		return m.MinKeySize
	}
	return 0
}

func (m *CSRParams) GetKeyType() KeyType {
	if m != nil {
		return m.KeyType
	}
	return KeyType_KT_UNKNOWN
}

func (m *CSRParams) GetCommonName() string {
	if m != nil {
		return m.CommonName
	}
	return ""
}

func (m *CSRParams) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

func (m *CSRParams) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *CSRParams) GetCity() string {
	if m != nil {
		return m.City
	}
	return ""
}

func (m *CSRParams) GetOrganization() string {
	if m != nil {
		return m.Organization
	}
	return ""
}

func (m *CSRParams) GetOrganizationalUnit() string {
	if m != nil {
		return m.OrganizationalUnit
	}
	return ""
}

func (m *CSRParams) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

func (m *CSRParams) GetEmailId() string {
	if m != nil {
		return m.EmailId
	}
	return ""
}

// GenerateCSRResponse contains the CSR associated with the Certificate ID
// supplied in the GenerateCSRRequest. When a Certificate is subsequently
// installed on the target in the same streaming RPC session, it must be
// associated to that Certificate ID.
//
// An Unimplemented error will be returned if the target cannot generate a CSR
// as per the request. In this case, the caller must generate its own key pair.
type GenerateCSRResponse struct {
	Csr *CSR `protobuf:"bytes,1,opt,name=csr" json:"csr,omitempty"`
}

func (m *GenerateCSRResponse) Reset()                    { *m = GenerateCSRResponse{} }
func (m *GenerateCSRResponse) String() string            { return proto.CompactTextString(m) }
func (*GenerateCSRResponse) ProtoMessage()               {}
func (*GenerateCSRResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *GenerateCSRResponse) GetCsr() *CSR {
	if m != nil {
		return m.Csr
	}
	return nil
}

// LoadCertificateRequest instructs the target to store the given certificate.
//
// Case 1: Target Generated CSR and Key Pair.
// If the target generated the CSR (and the public/private key pair) during the
// GenerateCSR request, then the target must associate the certificate with the
// certificate ID specified in the preceding GenerateCSR request.
//
// Case 2: Externally Generated Key Pair.
// If the target can not generate a CSR, then the public/private key pair is
// generated externally. In this case provide the target with the key pair,
// and the certificate_id to be associated with the new certificate.
//
// If there is another ongoing Rotate/Install RPC with the same certificate_id,
// the LoadCertificateRequest must fail.
type LoadCertificateRequest struct {
	// The certificate to be Loaded on the target.
	Certificate *Certificate `protobuf:"bytes,1,opt,name=certificate" json:"certificate,omitempty"`
	// The key pair to be used with the certificate. This is provided in the event
	// that the target cannot generate a CSR (and the corresponding public/private
	// keys).
	KeyPair *KeyPair `protobuf:"bytes,2,opt,name=key_pair,json=keyPair" json:"key_pair,omitempty"`
	// Certificate Id of the above certificate. This is to be provided only when
	// there is an externally generated key pair.
	CertificateId string `protobuf:"bytes,3,opt,name=certificate_id,json=certificateId" json:"certificate_id,omitempty"`
}

func (m *LoadCertificateRequest) Reset()                    { *m = LoadCertificateRequest{} }
func (m *LoadCertificateRequest) String() string            { return proto.CompactTextString(m) }
func (*LoadCertificateRequest) ProtoMessage()               {}
func (*LoadCertificateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *LoadCertificateRequest) GetCertificate() *Certificate {
	if m != nil {
		return m.Certificate
	}
	return nil
}

func (m *LoadCertificateRequest) GetKeyPair() *KeyPair {
	if m != nil {
		return m.KeyPair
	}
	return nil
}

func (m *LoadCertificateRequest) GetCertificateId() string {
	if m != nil {
		return m.CertificateId
	}
	return ""
}

// Response from target after Loading a Certificate.
// If the target could not load the certificate, it must end the RPC stream with
// a suitable RPC error about why the Certificate was not loaded.
type LoadCertificateResponse struct {
}

func (m *LoadCertificateResponse) Reset()                    { *m = LoadCertificateResponse{} }
func (m *LoadCertificateResponse) String() string            { return proto.CompactTextString(m) }
func (*LoadCertificateResponse) ProtoMessage()               {}
func (*LoadCertificateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

// A Finalize message is sent to the target to confirm the Rotation of
// the certificate and that the certificate should not be rolled back when
// the RPC concludes. The certificate must be rolled back if the target returns
// an error after receiving a Finalize message.
type FinalizeRequest struct {
}

func (m *FinalizeRequest) Reset()                    { *m = FinalizeRequest{} }
func (m *FinalizeRequest) String() string            { return proto.CompactTextString(m) }
func (*FinalizeRequest) ProtoMessage()               {}
func (*FinalizeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

// The request to query all the certificates on the target.
type GetCertificatesRequest struct {
}

func (m *GetCertificatesRequest) Reset()                    { *m = GetCertificatesRequest{} }
func (m *GetCertificatesRequest) String() string            { return proto.CompactTextString(m) }
func (*GetCertificatesRequest) ProtoMessage()               {}
func (*GetCertificatesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

// Response from the target about the certificates that exist on the target what
// what is using them.
type GetCertificatesResponse struct {
	CertificateInfo []*CertificateInfo `protobuf:"bytes,1,rep,name=certificate_info,json=certificateInfo" json:"certificate_info,omitempty"`
}

func (m *GetCertificatesResponse) Reset()                    { *m = GetCertificatesResponse{} }
func (m *GetCertificatesResponse) String() string            { return proto.CompactTextString(m) }
func (*GetCertificatesResponse) ProtoMessage()               {}
func (*GetCertificatesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *GetCertificatesResponse) GetCertificateInfo() []*CertificateInfo {
	if m != nil {
		return m.CertificateInfo
	}
	return nil
}

type CertificateInfo struct {
	CertificateId string       `protobuf:"bytes,1,opt,name=certificate_id,json=certificateId" json:"certificate_id,omitempty"`
	Certificate   *Certificate `protobuf:"bytes,2,opt,name=certificate" json:"certificate,omitempty"`
	// List of endpoints using this certificate.
	Endpoints []*Endpoint `protobuf:"bytes,3,rep,name=endpoints" json:"endpoints,omitempty"`
	// System modification time when the certificate was installed/rotated in
	// nanoseconds since epoch.
	ModificationTime int64 `protobuf:"varint,4,opt,name=modification_time,json=modificationTime" json:"modification_time,omitempty"`
}

func (m *CertificateInfo) Reset()                    { *m = CertificateInfo{} }
func (m *CertificateInfo) String() string            { return proto.CompactTextString(m) }
func (*CertificateInfo) ProtoMessage()               {}
func (*CertificateInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *CertificateInfo) GetCertificateId() string {
	if m != nil {
		return m.CertificateId
	}
	return ""
}

func (m *CertificateInfo) GetCertificate() *Certificate {
	if m != nil {
		return m.Certificate
	}
	return nil
}

func (m *CertificateInfo) GetEndpoints() []*Endpoint {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

func (m *CertificateInfo) GetModificationTime() int64 {
	if m != nil {
		return m.ModificationTime
	}
	return 0
}

type RevokeCertificatesRequest struct {
	// Certificates to revoke.
	CertificateId []string `protobuf:"bytes,1,rep,name=certificate_id,json=certificateId" json:"certificate_id,omitempty"`
}

func (m *RevokeCertificatesRequest) Reset()                    { *m = RevokeCertificatesRequest{} }
func (m *RevokeCertificatesRequest) String() string            { return proto.CompactTextString(m) }
func (*RevokeCertificatesRequest) ProtoMessage()               {}
func (*RevokeCertificatesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *RevokeCertificatesRequest) GetCertificateId() []string {
	if m != nil {
		return m.CertificateId
	}
	return nil
}

type RevokeCertificatesResponse struct {
	// List of certificates successfully revoked.
	RevokedCertificateId []string `protobuf:"bytes,1,rep,name=revoked_certificate_id,json=revokedCertificateId" json:"revoked_certificate_id,omitempty"`
	// List of errors why certain certificates could not be revoked.
	CertificateRevocationError []*CertificateRevocationError `protobuf:"bytes,2,rep,name=certificate_revocation_error,json=certificateRevocationError" json:"certificate_revocation_error,omitempty"`
}

func (m *RevokeCertificatesResponse) Reset()                    { *m = RevokeCertificatesResponse{} }
func (m *RevokeCertificatesResponse) String() string            { return proto.CompactTextString(m) }
func (*RevokeCertificatesResponse) ProtoMessage()               {}
func (*RevokeCertificatesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *RevokeCertificatesResponse) GetRevokedCertificateId() []string {
	if m != nil {
		return m.RevokedCertificateId
	}
	return nil
}

func (m *RevokeCertificatesResponse) GetCertificateRevocationError() []*CertificateRevocationError {
	if m != nil {
		return m.CertificateRevocationError
	}
	return nil
}

// An error message indicating why a certificate id could not be revoked.
type CertificateRevocationError struct {
	CertificateId string `protobuf:"bytes,1,opt,name=certificate_id,json=certificateId" json:"certificate_id,omitempty"`
	ErrorMessage  string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage" json:"error_message,omitempty"`
}

func (m *CertificateRevocationError) Reset()                    { *m = CertificateRevocationError{} }
func (m *CertificateRevocationError) String() string            { return proto.CompactTextString(m) }
func (*CertificateRevocationError) ProtoMessage()               {}
func (*CertificateRevocationError) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *CertificateRevocationError) GetCertificateId() string {
	if m != nil {
		return m.CertificateId
	}
	return ""
}

func (m *CertificateRevocationError) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

// A request to ask the target if it can generate key pairs.
type CanGenerateCSRRequest struct {
	KeyType         KeyType         `protobuf:"varint,1,opt,name=key_type,json=keyType,enum=gnoi.certificate.KeyType" json:"key_type,omitempty"`
	CertificateType CertificateType `protobuf:"varint,2,opt,name=certificate_type,json=certificateType,enum=gnoi.certificate.CertificateType" json:"certificate_type,omitempty"`
	KeySize         uint32          `protobuf:"varint,3,opt,name=key_size,json=keySize" json:"key_size,omitempty"`
}

func (m *CanGenerateCSRRequest) Reset()                    { *m = CanGenerateCSRRequest{} }
func (m *CanGenerateCSRRequest) String() string            { return proto.CompactTextString(m) }
func (*CanGenerateCSRRequest) ProtoMessage()               {}
func (*CanGenerateCSRRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *CanGenerateCSRRequest) GetKeyType() KeyType {
	if m != nil {
		return m.KeyType
	}
	return KeyType_KT_UNKNOWN
}

func (m *CanGenerateCSRRequest) GetCertificateType() CertificateType {
	if m != nil {
		return m.CertificateType
	}
	return CertificateType_CT_UNKNOWN
}

func (m *CanGenerateCSRRequest) GetKeySize() uint32 {
	if m != nil {
		return m.KeySize
	}
	return 0
}

// Response from the target about whether it can generate a CSR with the given
// parameters.
type CanGenerateCSRResponse struct {
	CanGenerate bool `protobuf:"varint,4,opt,name=can_generate,json=canGenerate" json:"can_generate,omitempty"`
}

func (m *CanGenerateCSRResponse) Reset()                    { *m = CanGenerateCSRResponse{} }
func (m *CanGenerateCSRResponse) String() string            { return proto.CompactTextString(m) }
func (*CanGenerateCSRResponse) ProtoMessage()               {}
func (*CanGenerateCSRResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *CanGenerateCSRResponse) GetCanGenerate() bool {
	if m != nil {
		return m.CanGenerate
	}
	return false
}

// A certificate.
type Certificate struct {
	// Type of certificate.
	Type CertificateType `protobuf:"varint,1,opt,name=type,enum=gnoi.certificate.CertificateType" json:"type,omitempty"`
	// Actual certificate.
	// The exact encoding depends upon the type of certificate.
	// for X509, this should be a PEM encoded Certificate.
	Certificate []byte `protobuf:"bytes,2,opt,name=certificate,proto3" json:"certificate,omitempty"`
}

func (m *Certificate) Reset()                    { *m = Certificate{} }
func (m *Certificate) String() string            { return proto.CompactTextString(m) }
func (*Certificate) ProtoMessage()               {}
func (*Certificate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *Certificate) GetType() CertificateType {
	if m != nil {
		return m.Type
	}
	return CertificateType_CT_UNKNOWN
}

func (m *Certificate) GetCertificate() []byte {
	if m != nil {
		return m.Certificate
	}
	return nil
}

// A Certificate Signing Request.
type CSR struct {
	// Type of certificate.
	Type CertificateType `protobuf:"varint,1,opt,name=type,enum=gnoi.certificate.CertificateType" json:"type,omitempty"`
	// Bytes representing the CSR.
	// The exact encoding depends upon the type of certificate requested.
	// for X509: This should be the PEM encoded CSR.
	Csr []byte `protobuf:"bytes,2,opt,name=csr,proto3" json:"csr,omitempty"`
}

func (m *CSR) Reset()                    { *m = CSR{} }
func (m *CSR) String() string            { return proto.CompactTextString(m) }
func (*CSR) ProtoMessage()               {}
func (*CSR) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *CSR) GetType() CertificateType {
	if m != nil {
		return m.Type
	}
	return CertificateType_CT_UNKNOWN
}

func (m *CSR) GetCsr() []byte {
	if m != nil {
		return m.Csr
	}
	return nil
}

// A message representing a pair of public/private keys.
type KeyPair struct {
	PrivateKey []byte `protobuf:"bytes,1,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
	PublicKey  []byte `protobuf:"bytes,2,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
}

func (m *KeyPair) Reset()                    { *m = KeyPair{} }
func (m *KeyPair) String() string            { return proto.CompactTextString(m) }
func (*KeyPair) ProtoMessage()               {}
func (*KeyPair) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *KeyPair) GetPrivateKey() []byte {
	if m != nil {
		return m.PrivateKey
	}
	return nil
}

func (m *KeyPair) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

// An endpoint represents an entity on the target which can use a certificate.
type Endpoint struct {
	Type Endpoint_Type `protobuf:"varint,1,opt,name=type,enum=gnoi.certificate.Endpoint_Type" json:"type,omitempty"`
	// Human readable identifier for an endpoint.
	Endpoint string `protobuf:"bytes,2,opt,name=endpoint" json:"endpoint,omitempty"`
}

func (m *Endpoint) Reset()                    { *m = Endpoint{} }
func (m *Endpoint) String() string            { return proto.CompactTextString(m) }
func (*Endpoint) ProtoMessage()               {}
func (*Endpoint) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *Endpoint) GetType() Endpoint_Type {
	if m != nil {
		return m.Type
	}
	return Endpoint_EP_UNSPECIFIED
}

func (m *Endpoint) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func init() {
	proto.RegisterType((*RotateCertificateRequest)(nil), "gnoi.certificate.RotateCertificateRequest")
	proto.RegisterType((*RotateCertificateResponse)(nil), "gnoi.certificate.RotateCertificateResponse")
	proto.RegisterType((*InstallCertificateRequest)(nil), "gnoi.certificate.InstallCertificateRequest")
	proto.RegisterType((*InstallCertificateResponse)(nil), "gnoi.certificate.InstallCertificateResponse")
	proto.RegisterType((*GenerateCSRRequest)(nil), "gnoi.certificate.GenerateCSRRequest")
	proto.RegisterType((*CSRParams)(nil), "gnoi.certificate.CSRParams")
	proto.RegisterType((*GenerateCSRResponse)(nil), "gnoi.certificate.GenerateCSRResponse")
	proto.RegisterType((*LoadCertificateRequest)(nil), "gnoi.certificate.LoadCertificateRequest")
	proto.RegisterType((*LoadCertificateResponse)(nil), "gnoi.certificate.LoadCertificateResponse")
	proto.RegisterType((*FinalizeRequest)(nil), "gnoi.certificate.FinalizeRequest")
	proto.RegisterType((*GetCertificatesRequest)(nil), "gnoi.certificate.GetCertificatesRequest")
	proto.RegisterType((*GetCertificatesResponse)(nil), "gnoi.certificate.GetCertificatesResponse")
	proto.RegisterType((*CertificateInfo)(nil), "gnoi.certificate.CertificateInfo")
	proto.RegisterType((*RevokeCertificatesRequest)(nil), "gnoi.certificate.RevokeCertificatesRequest")
	proto.RegisterType((*RevokeCertificatesResponse)(nil), "gnoi.certificate.RevokeCertificatesResponse")
	proto.RegisterType((*CertificateRevocationError)(nil), "gnoi.certificate.CertificateRevocationError")
	proto.RegisterType((*CanGenerateCSRRequest)(nil), "gnoi.certificate.CanGenerateCSRRequest")
	proto.RegisterType((*CanGenerateCSRResponse)(nil), "gnoi.certificate.CanGenerateCSRResponse")
	proto.RegisterType((*Certificate)(nil), "gnoi.certificate.Certificate")
	proto.RegisterType((*CSR)(nil), "gnoi.certificate.CSR")
	proto.RegisterType((*KeyPair)(nil), "gnoi.certificate.KeyPair")
	proto.RegisterType((*Endpoint)(nil), "gnoi.certificate.Endpoint")
	proto.RegisterEnum("gnoi.certificate.CertificateType", CertificateType_name, CertificateType_value)
	proto.RegisterEnum("gnoi.certificate.KeyType", KeyType_name, KeyType_value)
	proto.RegisterEnum("gnoi.certificate.Endpoint_Type", Endpoint_Type_name, Endpoint_Type_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for CertificateManagement service

type CertificateManagementClient interface {
	// Rotate will replace an existing Certificate on the target by creating a
	// new CSR request and placing the new Certificate based on the CSR on the
	// target. If the stream is broken or any steps in the process fail the
	// target must rollback to the original Certificate.
	//
	// The following describes the sequence of messages that must be exchanged
	// in the Rotate() RPC.
	//
	// Sequence of expected messages:
	// Case 1: When Target generates the CSR.
	//
	//   Step 1: Start the stream
	//     Client <---- Rotate() RPC stream begin ------> Target
	//
	//   Step 2: CSR
	//     Client -----> GenerateCSRRequest----> Target
	//     Client <----- GenerateCSRResponse <--- Target
	//
	//   Step 3: Certificate Signing
	//     Client gets the certificate signed by the CA.
	//
	//   Step 4: Send Certificate to Target.
	//     Client --> LoadCertificateRequest ----> Target
	//     Client <-- LoadCertificateResponse <--- Target
	//
	//   Step 5: Test/Validation by the client.
	//     This step should be to create a new connection to the target using
	//     The new certificate and validate that the certificate works.
	//     Once verfied, the client will then proceed to finalize the rotation.
	//     If the new connection cannot be completed the client will cancel the
	//     RPC thereby forcing the target to rollback the certificate.
	//
	//   Step 6: Final commit.
	//     Client ---> FinalizeRequest ----> Target
	//
	//
	// Case 2: When Client generates the CSR.
	//   Step 1: Start the stream
	//     Client <---- Rotate() RPC stream begin ----> Target
	//
	//   Step 2: CSR
	//     Client generates its own certificate.
	//
	//   Step 3: Certificate Signing
	//     Client gets the certificate signed by the CA.
	//
	//   Step 4: Send Certificate to Target.
	//     Client ---> LoadCertificateRequest ----> Target
	//     Client <--- LoadCertificateResponse <--- Target
	//
	//   Step 5: Test/Validation by the client.
	//
	//   Step 6: Final commit.
	//     Client ---> FinalizeRequest ----> Target
	Rotate(ctx context.Context, opts ...grpc.CallOption) (CertificateManagement_RotateClient, error)
	// Install will put a new Certificate on the target by creating a new CSR
	// request and placing the new Certificate based on the CSR on the target.The
	// new Certificate will be associated with a new Certificate Id on the target.
	// If the target has a pre existing Certificate with the given Certificate Id,
	// the operation should fail.
	// If the stream is broken or any steps in the process fail the target must
	// revert any changes in state.
	//
	// The following describes the sequence of messages that must be exchanged
	// in the Install() RPC.
	//
	// Sequence of expected messages:
	// Case 1: When Target generates the CSR-------------------------:
	//
	//   Step 1: Start the stream
	//     Client <---- Install() RPC stream begin ------> Target
	//
	//   Step 2: CSR
	//     Client -----> GenerateCSRRequest() ----> Target
	//     Client <---- GenerateCSRResponse() <---- Target
	//
	//   Step 3: Certificate Signing
	//     Client gets the certificate signed by the CA.
	//
	//   Step 4: Send Certificate to Target.
	//     Client -> LoadCertificateRequest() ----> Target
	//     Client <- LoadCertificateResponse() <--- Target
	//
	// Case 2: When Client generates the CSR-------------------------:
	//   Step 1: Start the stream
	//     Client <---- Install() RPC stream begin ------> Target
	//
	//   Step 2: CSR
	//     Client generates its own certificate.
	//
	//   Step 3: Certificate Signing
	//     Client gets the certificate signed by the CA.
	//
	//   Step 4: Send Certificate to Target.
	//     Client -> LoadCertificateRequest() ----> Target
	//     Client <- LoadCertificateResponse() <--- Target
	//
	Install(ctx context.Context, opts ...grpc.CallOption) (CertificateManagement_InstallClient, error)
	// An RPC to get the certificates on the target.
	GetCertificates(ctx context.Context, in *GetCertificatesRequest, opts ...grpc.CallOption) (*GetCertificatesResponse, error)
	// An RPC to revoke specific certificates.
	// If a certificate is not present on the target, the request should silently
	// succeed. Revoking a certificate should render the existing certificate
	// unusable by any endpoints.
	RevokeCertificates(ctx context.Context, in *RevokeCertificatesRequest, opts ...grpc.CallOption) (*RevokeCertificatesResponse, error)
	// An RPC to ask a target if it can generate a Certificate.
	CanGenerateCSR(ctx context.Context, in *CanGenerateCSRRequest, opts ...grpc.CallOption) (*CanGenerateCSRResponse, error)
}

type certificateManagementClient struct {
	cc *grpc.ClientConn
}

func NewCertificateManagementClient(cc *grpc.ClientConn) CertificateManagementClient {
	return &certificateManagementClient{cc}
}

func (c *certificateManagementClient) Rotate(ctx context.Context, opts ...grpc.CallOption) (CertificateManagement_RotateClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CertificateManagement_serviceDesc.Streams[0], c.cc, "/gnoi.certificate.CertificateManagement/Rotate", opts...)
	if err != nil {
		return nil, err
	}
	x := &certificateManagementRotateClient{stream}
	return x, nil
}

type CertificateManagement_RotateClient interface {
	Send(*RotateCertificateRequest) error
	Recv() (*RotateCertificateResponse, error)
	grpc.ClientStream
}

type certificateManagementRotateClient struct {
	grpc.ClientStream
}

func (x *certificateManagementRotateClient) Send(m *RotateCertificateRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *certificateManagementRotateClient) Recv() (*RotateCertificateResponse, error) {
	m := new(RotateCertificateResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *certificateManagementClient) Install(ctx context.Context, opts ...grpc.CallOption) (CertificateManagement_InstallClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CertificateManagement_serviceDesc.Streams[1], c.cc, "/gnoi.certificate.CertificateManagement/Install", opts...)
	if err != nil {
		return nil, err
	}
	x := &certificateManagementInstallClient{stream}
	return x, nil
}

type CertificateManagement_InstallClient interface {
	Send(*InstallCertificateRequest) error
	Recv() (*InstallCertificateResponse, error)
	grpc.ClientStream
}

type certificateManagementInstallClient struct {
	grpc.ClientStream
}

func (x *certificateManagementInstallClient) Send(m *InstallCertificateRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *certificateManagementInstallClient) Recv() (*InstallCertificateResponse, error) {
	m := new(InstallCertificateResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *certificateManagementClient) GetCertificates(ctx context.Context, in *GetCertificatesRequest, opts ...grpc.CallOption) (*GetCertificatesResponse, error) {
	out := new(GetCertificatesResponse)
	err := grpc.Invoke(ctx, "/gnoi.certificate.CertificateManagement/GetCertificates", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certificateManagementClient) RevokeCertificates(ctx context.Context, in *RevokeCertificatesRequest, opts ...grpc.CallOption) (*RevokeCertificatesResponse, error) {
	out := new(RevokeCertificatesResponse)
	err := grpc.Invoke(ctx, "/gnoi.certificate.CertificateManagement/RevokeCertificates", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certificateManagementClient) CanGenerateCSR(ctx context.Context, in *CanGenerateCSRRequest, opts ...grpc.CallOption) (*CanGenerateCSRResponse, error) {
	out := new(CanGenerateCSRResponse)
	err := grpc.Invoke(ctx, "/gnoi.certificate.CertificateManagement/CanGenerateCSR", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for CertificateManagement service

type CertificateManagementServer interface {
	// Rotate will replace an existing Certificate on the target by creating a
	// new CSR request and placing the new Certificate based on the CSR on the
	// target. If the stream is broken or any steps in the process fail the
	// target must rollback to the original Certificate.
	//
	// The following describes the sequence of messages that must be exchanged
	// in the Rotate() RPC.
	//
	// Sequence of expected messages:
	// Case 1: When Target generates the CSR.
	//
	//   Step 1: Start the stream
	//     Client <---- Rotate() RPC stream begin ------> Target
	//
	//   Step 2: CSR
	//     Client -----> GenerateCSRRequest----> Target
	//     Client <----- GenerateCSRResponse <--- Target
	//
	//   Step 3: Certificate Signing
	//     Client gets the certificate signed by the CA.
	//
	//   Step 4: Send Certificate to Target.
	//     Client --> LoadCertificateRequest ----> Target
	//     Client <-- LoadCertificateResponse <--- Target
	//
	//   Step 5: Test/Validation by the client.
	//     This step should be to create a new connection to the target using
	//     The new certificate and validate that the certificate works.
	//     Once verfied, the client will then proceed to finalize the rotation.
	//     If the new connection cannot be completed the client will cancel the
	//     RPC thereby forcing the target to rollback the certificate.
	//
	//   Step 6: Final commit.
	//     Client ---> FinalizeRequest ----> Target
	//
	//
	// Case 2: When Client generates the CSR.
	//   Step 1: Start the stream
	//     Client <---- Rotate() RPC stream begin ----> Target
	//
	//   Step 2: CSR
	//     Client generates its own certificate.
	//
	//   Step 3: Certificate Signing
	//     Client gets the certificate signed by the CA.
	//
	//   Step 4: Send Certificate to Target.
	//     Client ---> LoadCertificateRequest ----> Target
	//     Client <--- LoadCertificateResponse <--- Target
	//
	//   Step 5: Test/Validation by the client.
	//
	//   Step 6: Final commit.
	//     Client ---> FinalizeRequest ----> Target
	Rotate(CertificateManagement_RotateServer) error
	// Install will put a new Certificate on the target by creating a new CSR
	// request and placing the new Certificate based on the CSR on the target.The
	// new Certificate will be associated with a new Certificate Id on the target.
	// If the target has a pre existing Certificate with the given Certificate Id,
	// the operation should fail.
	// If the stream is broken or any steps in the process fail the target must
	// revert any changes in state.
	//
	// The following describes the sequence of messages that must be exchanged
	// in the Install() RPC.
	//
	// Sequence of expected messages:
	// Case 1: When Target generates the CSR-------------------------:
	//
	//   Step 1: Start the stream
	//     Client <---- Install() RPC stream begin ------> Target
	//
	//   Step 2: CSR
	//     Client -----> GenerateCSRRequest() ----> Target
	//     Client <---- GenerateCSRResponse() <---- Target
	//
	//   Step 3: Certificate Signing
	//     Client gets the certificate signed by the CA.
	//
	//   Step 4: Send Certificate to Target.
	//     Client -> LoadCertificateRequest() ----> Target
	//     Client <- LoadCertificateResponse() <--- Target
	//
	// Case 2: When Client generates the CSR-------------------------:
	//   Step 1: Start the stream
	//     Client <---- Install() RPC stream begin ------> Target
	//
	//   Step 2: CSR
	//     Client generates its own certificate.
	//
	//   Step 3: Certificate Signing
	//     Client gets the certificate signed by the CA.
	//
	//   Step 4: Send Certificate to Target.
	//     Client -> LoadCertificateRequest() ----> Target
	//     Client <- LoadCertificateResponse() <--- Target
	//
	Install(CertificateManagement_InstallServer) error
	// An RPC to get the certificates on the target.
	GetCertificates(context.Context, *GetCertificatesRequest) (*GetCertificatesResponse, error)
	// An RPC to revoke specific certificates.
	// If a certificate is not present on the target, the request should silently
	// succeed. Revoking a certificate should render the existing certificate
	// unusable by any endpoints.
	RevokeCertificates(context.Context, *RevokeCertificatesRequest) (*RevokeCertificatesResponse, error)
	// An RPC to ask a target if it can generate a Certificate.
	CanGenerateCSR(context.Context, *CanGenerateCSRRequest) (*CanGenerateCSRResponse, error)
}

func RegisterCertificateManagementServer(s *grpc.Server, srv CertificateManagementServer) {
	s.RegisterService(&_CertificateManagement_serviceDesc, srv)
}

func _CertificateManagement_Rotate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CertificateManagementServer).Rotate(&certificateManagementRotateServer{stream})
}

type CertificateManagement_RotateServer interface {
	Send(*RotateCertificateResponse) error
	Recv() (*RotateCertificateRequest, error)
	grpc.ServerStream
}

type certificateManagementRotateServer struct {
	grpc.ServerStream
}

func (x *certificateManagementRotateServer) Send(m *RotateCertificateResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *certificateManagementRotateServer) Recv() (*RotateCertificateRequest, error) {
	m := new(RotateCertificateRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _CertificateManagement_Install_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CertificateManagementServer).Install(&certificateManagementInstallServer{stream})
}

type CertificateManagement_InstallServer interface {
	Send(*InstallCertificateResponse) error
	Recv() (*InstallCertificateRequest, error)
	grpc.ServerStream
}

type certificateManagementInstallServer struct {
	grpc.ServerStream
}

func (x *certificateManagementInstallServer) Send(m *InstallCertificateResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *certificateManagementInstallServer) Recv() (*InstallCertificateRequest, error) {
	m := new(InstallCertificateRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _CertificateManagement_GetCertificates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCertificatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertificateManagementServer).GetCertificates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gnoi.certificate.CertificateManagement/GetCertificates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertificateManagementServer).GetCertificates(ctx, req.(*GetCertificatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CertificateManagement_RevokeCertificates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeCertificatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertificateManagementServer).RevokeCertificates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gnoi.certificate.CertificateManagement/RevokeCertificates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertificateManagementServer).RevokeCertificates(ctx, req.(*RevokeCertificatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CertificateManagement_CanGenerateCSR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CanGenerateCSRRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertificateManagementServer).CanGenerateCSR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gnoi.certificate.CertificateManagement/CanGenerateCSR",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertificateManagementServer).CanGenerateCSR(ctx, req.(*CanGenerateCSRRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CertificateManagement_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gnoi.certificate.CertificateManagement",
	HandlerType: (*CertificateManagementServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCertificates",
			Handler:    _CertificateManagement_GetCertificates_Handler,
		},
		{
			MethodName: "RevokeCertificates",
			Handler:    _CertificateManagement_RevokeCertificates_Handler,
		},
		{
			MethodName: "CanGenerateCSR",
			Handler:    _CertificateManagement_CanGenerateCSR_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Rotate",
			Handler:       _CertificateManagement_Rotate_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Install",
			Handler:       _CertificateManagement_Install_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "cert/cert.proto",
}

func init() { proto.RegisterFile("cert/cert.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1224 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x57, 0xdf, 0x6e, 0xda, 0x56,
	0x18, 0x8f, 0x43, 0x1a, 0xe0, 0x83, 0x80, 0x73, 0xd2, 0xa4, 0x86, 0xad, 0x6a, 0xea, 0x2d, 0x6a,
	0x9a, 0x56, 0x24, 0x4a, 0x5b, 0x69, 0x5b, 0xa5, 0x4e, 0x09, 0xa5, 0x0d, 0x22, 0xa1, 0xc8, 0x90,
	0x6d, 0xda, 0x8d, 0xe5, 0x98, 0x03, 0x39, 0x0a, 0x3e, 0xc7, 0xb3, 0x9d, 0x4e, 0xe4, 0x21, 0xf6,
	0x02, 0xbb, 0xd9, 0xd5, 0x1e, 0x61, 0x0f, 0xb0, 0x27, 0xd8, 0xc5, 0xb4, 0xeb, 0x3d, 0xca, 0xe4,
	0x73, 0x0c, 0x18, 0x7c, 0x48, 0x59, 0xef, 0x7a, 0x83, 0xec, 0xef, 0xfb, 0x7d, 0x3f, 0x7f, 0xff,
	0xcf, 0x01, 0x8a, 0x36, 0xf6, 0x82, 0xfd, 0xf0, 0xa7, 0xe2, 0x7a, 0x2c, 0x60, 0x48, 0xed, 0x53,
	0x46, 0x2a, 0xa1, 0x80, 0xf4, 0x88, 0x6d, 0x05, 0x58, 0xff, 0x6d, 0x19, 0x34, 0x83, 0x05, 0x56,
	0x80, 0xab, 0x13, 0xa9, 0x81, 0x7f, 0xba, 0xc6, 0x7e, 0x80, 0xea, 0x90, 0xef, 0x63, 0x8a, 0x3d,
	0x2b, 0xc0, 0xa6, 0xed, 0x7b, 0x9a, 0xb2, 0xad, 0xec, 0xe6, 0x0e, 0xbf, 0xac, 0xcc, 0xb2, 0x54,
	0xde, 0x46, 0xa8, 0x6a, 0xdb, 0x88, 0x6c, 0x4f, 0x96, 0x8c, 0xdc, 0xc8, 0xb6, 0xea, 0x7b, 0xe8,
	0x1c, 0xd4, 0x01, 0xb3, 0xba, 0x66, 0xcc, 0x4a, 0x5b, 0xe6, 0x74, 0xbb, 0x49, 0xba, 0x53, 0x66,
	0x75, 0x93, 0xee, 0x9c, 0x2c, 0x19, 0xc5, 0xc1, 0xb4, 0x06, 0xb5, 0x60, 0xbd, 0x47, 0xa8, 0x35,
	0x20, 0x37, 0xd8, 0xf4, 0xc2, 0x30, 0x08, 0xa3, 0x5a, 0x8a, 0xf3, 0x3e, 0x4c, 0xf2, 0xbe, 0x89,
	0xa0, 0x13, 0x42, 0x75, 0x64, 0x6d, 0x44, 0xc6, 0xc7, 0x2a, 0x14, 0x38, 0x11, 0x36, 0x3d, 0x81,
	0xd2, 0xff, 0x56, 0xa0, 0x24, 0x49, 0x91, 0xef, 0x32, 0xea, 0x63, 0x74, 0x0a, 0x6b, 0xa3, 0x38,
	0xbb, 0xb1, 0x24, 0xed, 0x7c, 0x20, 0x49, 0xc2, 0xfa, 0x64, 0xc9, 0x18, 0x67, 0xb8, 0x1b, 0xa6,
	0xe9, 0xbb, 0xb9, 0x69, 0x7a, 0xbc, 0x40, 0x9a, 0xc6, 0xa4, 0xb3, 0x79, 0x3a, 0x5e, 0x87, 0xe2,
	0x38, 0x2a, 0x81, 0xd2, 0xff, 0x52, 0xa0, 0x54, 0xa7, 0x7e, 0x60, 0x0d, 0x06, 0x9f, 0x62, 0xe9,
	0xc3, 0x90, 0x88, 0x70, 0x7f, 0x5c, 0xa9, 0x7f, 0x14, 0x28, 0xcb, 0x42, 0xfa, 0xa4, 0x4a, 0x85,
	0x40, 0x9d, 0xc4, 0x15, 0xd5, 0xea, 0x67, 0x40, 0xc9, 0x3c, 0xa3, 0x6f, 0x00, 0x6c, 0xdf, 0x33,
	0x5d, 0xcb, 0xb3, 0x1c, 0x3f, 0x0a, 0xe6, 0xb3, 0xe4, 0xb7, 0xab, 0x6d, 0xa3, 0xc5, 0x21, 0x46,
	0xd6, 0xf6, 0x3d, 0xf1, 0x88, 0x76, 0xa0, 0x10, 0xc3, 0x98, 0xa4, 0xcb, 0x7d, 0xcf, 0x1a, 0x6b,
	0x31, 0x69, 0xbd, 0xab, 0xff, 0x92, 0x82, 0xec, 0xd8, 0x1e, 0xbd, 0x80, 0x95, 0x60, 0xe8, 0x62,
	0xfe, 0xa9, 0x82, 0x6c, 0xc0, 0x62, 0x71, 0x74, 0x86, 0x2e, 0x36, 0x38, 0x1c, 0x6d, 0x43, 0xde,
	0x21, 0xd4, 0xbc, 0xc2, 0x43, 0xd3, 0x27, 0x37, 0x22, 0x4b, 0x6b, 0x06, 0x38, 0x84, 0x36, 0xf0,
	0xb0, 0x4d, 0x6e, 0x30, 0x7a, 0x0e, 0x99, 0x50, 0xcb, 0xc9, 0x53, 0x9c, 0xbc, 0x94, 0x24, 0x6f,
	0xe0, 0x21, 0x27, 0x4d, 0x5f, 0x89, 0x07, 0xf4, 0x00, 0x72, 0x36, 0x73, 0x1c, 0x46, 0x4d, 0x6a,
	0x39, 0x58, 0x5b, 0xe1, 0x01, 0x80, 0x10, 0x35, 0x2d, 0x07, 0x23, 0x0d, 0xd2, 0x36, 0xbb, 0xa6,
	0x81, 0x37, 0xd4, 0xee, 0x70, 0xe5, 0xe8, 0x15, 0xdd, 0x85, 0x3b, 0x7e, 0x38, 0x0e, 0xda, 0x2a,
	0x97, 0x8b, 0x17, 0x84, 0x60, 0xc5, 0x26, 0xc1, 0x50, 0x4b, 0x73, 0x21, 0x7f, 0x46, 0x3a, 0xe4,
	0x99, 0xd7, 0xb7, 0x28, 0xb9, 0x11, 0xcb, 0x25, 0xc3, 0x75, 0x53, 0x32, 0xb4, 0x0f, 0x1b, 0xf1,
	0x77, 0x6b, 0x60, 0x5e, 0x53, 0x12, 0x68, 0x59, 0x0e, 0x45, 0xd3, 0xaa, 0x73, 0x4a, 0x02, 0x74,
	0x1f, 0x80, 0xb8, 0xa6, 0xd5, 0xed, 0x7a, 0xd8, 0xf7, 0x35, 0xe0, 0xb8, 0x2c, 0x71, 0x8f, 0x84,
	0x00, 0x95, 0x20, 0x83, 0x1d, 0x8b, 0x0c, 0xc2, 0xb2, 0xe4, 0x84, 0xe3, 0xfc, 0xbd, 0xde, 0xd5,
	0x5f, 0xc1, 0x86, 0xa4, 0x39, 0xd1, 0x23, 0x48, 0x4d, 0x1a, 0x7a, 0x53, 0xda, 0x03, 0x46, 0x88,
	0xd0, 0xff, 0x50, 0x60, 0x4b, 0x3e, 0x63, 0xe8, 0x5b, 0xc8, 0xc5, 0x7b, 0x59, 0x70, 0xdd, 0xbf,
	0xb5, 0xc8, 0x46, 0xdc, 0x62, 0x54, 0x45, 0xd7, 0x22, 0x5e, 0x34, 0x09, 0xf2, 0x2a, 0xb6, 0x2c,
	0xe2, 0xf1, 0x2a, 0x86, 0x0f, 0x92, 0x4e, 0x4c, 0xc9, 0x3a, 0xb1, 0x04, 0xf7, 0xe6, 0x0c, 0x91,
	0xbe, 0x0e, 0xc5, 0x99, 0xcd, 0xae, 0x6b, 0xb0, 0xf5, 0x16, 0x07, 0x31, 0xb0, 0x3f, 0xd2, 0xf4,
	0xe1, 0x5e, 0x42, 0x33, 0xde, 0x0f, 0xea, 0x94, 0x27, 0xb4, 0xc7, 0x34, 0x65, 0x3b, 0x25, 0x3f,
	0x4b, 0x62, 0x0c, 0x75, 0xda, 0x63, 0x46, 0xd1, 0x9e, 0x16, 0xe8, 0xff, 0x2a, 0x50, 0x9c, 0x01,
	0x49, 0x62, 0x55, 0x24, 0xb1, 0xce, 0x56, 0x62, 0xf9, 0x7f, 0x57, 0xe2, 0x2b, 0xc8, 0x62, 0xda,
	0x75, 0x19, 0xa1, 0x81, 0xaf, 0xa5, 0x78, 0x08, 0xe5, 0xa4, 0x79, 0x2d, 0x82, 0x18, 0x13, 0x30,
	0x7a, 0x02, 0xeb, 0x0e, 0xeb, 0x0a, 0x04, 0x61, 0xd4, 0x0c, 0x48, 0x34, 0x59, 0x29, 0x43, 0x8d,
	0x2b, 0x3a, 0xc4, 0xc1, 0xfa, 0x31, 0x94, 0x0c, 0xfc, 0x9e, 0x5d, 0x61, 0x49, 0xa2, 0xa5, 0xb1,
	0xa6, 0x92, 0x75, 0xfd, 0x53, 0x81, 0xb2, 0x8c, 0x24, 0xaa, 0xc9, 0x73, 0xd8, 0xf2, 0xb8, 0x76,
	0x6a, 0xd1, 0x4e, 0xd8, 0xee, 0x46, 0xda, 0xea, 0x54, 0x02, 0x29, 0x7c, 0x1e, 0x47, 0x87, 0x98,
	0x28, 0x1e, 0xec, 0x79, 0x2c, 0xec, 0xce, 0x30, 0x25, 0x4f, 0x6f, 0xcf, 0xe8, 0xd8, 0xa8, 0x16,
	0xda, 0x18, 0x65, 0x7b, 0xae, 0x4e, 0xbf, 0x84, 0xf2, 0x7c, 0xcb, 0x45, 0xab, 0xfe, 0x05, 0xac,
	0x71, 0xef, 0x4c, 0x07, 0xfb, 0xbe, 0xd5, 0xc7, 0xd1, 0x46, 0xce, 0x73, 0xe1, 0x99, 0x90, 0x85,
	0xf3, 0xbb, 0x59, 0xb5, 0xa8, 0xe4, 0x34, 0x88, 0xef, 0x50, 0x65, 0xe1, 0x1d, 0x3a, 0xd3, 0xf3,
	0xdc, 0x7a, 0x79, 0xd1, 0xf5, 0x1e, 0xef, 0x79, 0xce, 0x56, 0x12, 0x3e, 0xf0, 0x2d, 0x9f, 0xe2,
	0x5b, 0x3e, 0xfc, 0x50, 0xb8, 0xe2, 0xf5, 0x97, 0xb0, 0x35, 0xeb, 0x77, 0x54, 0xe2, 0x87, 0x90,
	0xb7, 0x2d, 0x6a, 0x8e, 0x0e, 0x57, 0xde, 0x6d, 0x19, 0x23, 0x67, 0x4f, 0xd0, 0x7a, 0x0f, 0x72,
	0xf1, 0x5b, 0xdf, 0x47, 0x9f, 0x43, 0x89, 0xb1, 0xca, 0x4f, 0xcd, 0x8d, 0xde, 0x84, 0x54, 0xb5,
	0x6d, 0x7c, 0x2c, 0xbf, 0x2a, 0x96, 0xb0, 0xe0, 0xe5, 0xdb, 0xb6, 0x0e, 0xe9, 0x68, 0xdf, 0x85,
	0x87, 0x95, 0xeb, 0x91, 0xf7, 0x61, 0x92, 0xaf, 0xf0, 0x90, 0x53, 0xe7, 0x0d, 0x88, 0x44, 0x0d,
	0x3c, 0x0c, 0xcf, 0x04, 0xf7, 0xfa, 0x62, 0x40, 0x6c, 0xae, 0x17, 0x24, 0x59, 0x21, 0x69, 0xe0,
	0xa1, 0xfe, 0xab, 0x02, 0x99, 0xd1, 0xc0, 0xa2, 0x67, 0x53, 0x0e, 0x3e, 0x98, 0x3f, 0xda, 0x95,
	0x98, 0x7b, 0x65, 0xc8, 0x8c, 0xe6, 0x3c, 0x6a, 0xad, 0xf1, 0xbb, 0xfe, 0x0a, 0x56, 0x78, 0x01,
	0x11, 0x14, 0x6a, 0x2d, 0xf3, 0xbc, 0xd9, 0x6e, 0xd5, 0xaa, 0xf5, 0x37, 0xf5, 0xda, 0x6b, 0x75,
	0x09, 0x6d, 0x40, 0xb1, 0xd6, 0x32, 0xeb, 0xad, 0x76, 0xad, 0x6a, 0x76, 0xce, 0x9b, 0xcd, 0xda,
	0xa9, 0xaa, 0xa0, 0x35, 0xc8, 0xd6, 0x5a, 0xe6, 0xeb, 0xa3, 0xda, 0xd9, 0xbb, 0xa6, 0xba, 0xbc,
	0x57, 0x99, 0xda, 0x75, 0x9c, 0xaa, 0x00, 0x50, 0xed, 0x98, 0xe7, 0xcd, 0x46, 0xf3, 0xdd, 0xf7,
	0x4d, 0x75, 0x09, 0xe5, 0x20, 0x5d, 0xed, 0x98, 0x3f, 0xbc, 0x38, 0xf8, 0x5a, 0x55, 0xf6, 0x76,
	0x78, 0x62, 0x46, 0xb8, 0x46, 0x1c, 0x07, 0xb0, 0xda, 0xe8, 0x98, 0x46, 0xfb, 0x48, 0x55, 0x0e,
	0x7f, 0x5f, 0x81, 0xcd, 0x18, 0xef, 0x99, 0x45, 0xad, 0x3e, 0x76, 0x30, 0x0d, 0x10, 0x86, 0x55,
	0x71, 0x27, 0x47, 0x7b, 0xc9, 0xe8, 0xe7, 0xfd, 0xa1, 0x29, 0x3f, 0x59, 0x08, 0x2b, 0xfa, 0x72,
	0x57, 0x39, 0x50, 0xd0, 0x25, 0xa4, 0xa3, 0x0b, 0x25, 0x92, 0xd8, 0xce, 0xbd, 0x3e, 0x97, 0x9f,
	0x2e, 0x06, 0x8e, 0x7d, 0xa9, 0x07, 0xc5, 0x99, 0x73, 0x09, 0xed, 0xca, 0x2e, 0xa6, 0xb2, 0x43,
	0xad, 0xfc, 0x78, 0x01, 0x64, 0x34, 0x6d, 0x0c, 0x50, 0x72, 0xdd, 0xca, 0x82, 0x9b, 0xbb, 0xd9,
	0x65, 0xc1, 0xdd, 0xb2, 0xc1, 0x6d, 0x28, 0x4c, 0x0f, 0x3e, 0x7a, 0x24, 0x19, 0x28, 0xd9, 0x4a,
	0x2b, 0xef, 0x7e, 0x18, 0x28, 0x3e, 0x72, 0x7c, 0xf8, 0xe3, 0x41, 0x9f, 0x04, 0x97, 0xd7, 0x17,
	0x15, 0x9b, 0x39, 0xfb, 0xcc, 0xc5, 0xd4, 0x66, 0xb4, 0x47, 0xfa, 0xfb, 0x21, 0x01, 0xff, 0x07,
	0xfc, 0x72, 0x96, 0xea, 0x62, 0x95, 0xff, 0x27, 0x7e, 0xf6, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0xbe, 0x7b, 0x80, 0xe3, 0x26, 0x0f, 0x00, 0x00,
}
